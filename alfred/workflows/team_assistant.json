{
  "id": "KJpZBr3isT66Rzoa",
  "name": "\ud83e\udd16 Alfred | Team Assistant",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "trigger": [
          "app_mention",
          "message"
        ],
        "watchWorkspace": true,
        "options": {
          "userIds": [
            "U0AC80Z0HR9"
          ]
        }
      },
      "id": "slack-trigger",
      "name": "Slack Trigger",
      "type": "n8n-nodes-base.slackTrigger",
      "typeVersion": 1,
      "position": [
        256,
        348
      ],
      "webhookId": "819d30ff-6523-479e-bda7-285540d516c7",
      "credentials": {
        "slackApi": {
          "id": "apG1iXE1E50lr9RH",
          "name": "Slack account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const event = $input.first().json;\n\n// Filter out bot messages to prevent Alfred from responding to itself\nconst botId = event.bot_id || event.event?.bot_id;\nconst subtype = event.subtype || event.event?.subtype;\n\nif (botId || subtype === 'bot_message') {\n  // Return empty array to stop workflow execution for bot messages\n  return [];\n}\n\n// Filter out message_changed events (Slack sends these after unfurling links)\n// These cause duplicate executions with different data structure\nif (subtype === 'message_changed' || event.hidden === true) {\n  console.log('[Normalize Input] Filtering out message_changed/hidden event');\n  return [];\n}\n\nconst slackUserId = event.user || event.event?.user;\nconst channelId = event.channel || event.event?.channel;\nconst threadTs = event.thread_ts || event.event?.thread_ts || event.ts || event.event?.ts;\nconst messageText = event.text || event.event?.text || '';\n\n// Only strip the Alfred bot mention, keep other user mentions intact\n// Alfred's bot user ID is U0AC80Z0HR9\nconst cleanedText = messageText.replace(/<@U0AC80Z0HR9>/g, '').trim();\n\n// Extract all user mentions from the message (for tools like create_user)\nconst mentionPattern = /<@([A-Z0-9]+)>/g;\nconst mentions = [];\nlet match;\nwhile ((match = mentionPattern.exec(messageText)) !== null) {\n  // Exclude Alfred's own bot ID\n  if (match[1] !== 'U0AC80Z0HR9') {\n    mentions.push(match[1]);\n  }\n}\n\nlet triggerType = 'unknown';\nif (event.event?.type === 'app_mention') {\n  triggerType = 'mention';\n} else if (event.event?.channel_type === 'im') {\n  triggerType = 'dm';\n} else if (event.channel_type === 'im') {\n  triggerType = 'dm';\n} else {\n  triggerType = 'channel';\n}\n\n// Detect actual thread reply: raw thread_ts differs from message ts\nconst rawTs = event.ts || event.event?.ts;\nconst rawThreadTs = event.thread_ts || event.event?.thread_ts;\nconst isThreadReply = !!(rawThreadTs && rawThreadTs !== rawTs);\n\nlet responseType = 'thread';\nif (triggerType === 'dm' && !isThreadReply) {\n  // New DM (not a thread reply) \u2014 respond as top-level DM\n  responseType = 'dm';\n} else if (isThreadReply) {\n  // Thread reply (in DM or channel) \u2014 respond in-thread\n  responseType = 'thread';\n} else {\n  responseType = 'channel';\n}\n\nreturn [{\n  json: {\n    slack_user_id: slackUserId,\n    channel_id: channelId,\n    thread_ts: threadTs,\n    message_text: cleanedText,\n    mentioned_user_ids: mentions,\n    trigger_type: triggerType,\n    response_type: responseType,\n    raw_event: event\n  }\n}];"
      },
      "id": "normalize-input",
      "name": "Normalize Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        348
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "mHy10eByiuuyr8U1"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "slack_user_id": "={{ $json.slack_user_id }}"
          }
        },
        "options": {}
      },
      "id": "user-lookup",
      "name": "Lookup User",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        704,
        444
      ]
    },
    {
      "parameters": {
        "jsCode": "const lookupResult = $input.first().json;\n\n// Get normalized input - could be from either Slack trigger or sub-workflow\nlet normalizedInput = {};\ntry {\n  normalizedInput = $('Normalize Input').first().json;\n} catch (e) {\n  try {\n    normalizedInput = $('Normalize Sub-workflow Input').first().json;\n  } catch (e2) {\n    // If neither exists, extract what we can from lookup result or use defaults\n    normalizedInput = {\n      slack_user_id: lookupResult.user?.slack_user_id || '',\n      channel_id: '',\n      thread_ts: '',\n      message_text: '',\n      trigger_type: 'subworkflow',\n      response_type: 'dm'\n    };\n  }\n}\n\nlet userData = null;\nlet isFound = false;\n\nif (lookupResult.found === true && lookupResult.user) {\n  userData = lookupResult.user;\n  isFound = true;\n} else if (lookupResult.id && lookupResult.slack_user_id) {\n  userData = lookupResult;\n  isFound = true;\n}\n\nif (isFound && userData) {\n  return [{\n    json: {\n      authorized: true,\n      user: userData,\n      is_admin: userData.role === 'admin',\n      ...normalizedInput\n    }\n  }];\n} else {\n  return [{\n    json: {\n      authorized: false,\n      error: lookupResult.error || 'User not found',\n      ...normalizedInput\n    }\n  }];\n}"
      },
      "id": "check-user",
      "name": "Check User Found",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        444
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "auth-check",
              "leftValue": "={{ $json.authorized }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-auth",
      "name": "Route by Auth",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1152,
        444
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "response",
              "name": "response_text",
              "value": "I don't recognize you yet! Please contact an admin to get registered with Alfred.",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "unauthorized-response",
      "name": "Unauthorized Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1376,
        540
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "aPGhgQ2p6A7aygUt"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "response_text": "={{ $json.response_text }}",
            "slack_user_id": "={{ $('Check User Found').item.json.slack_user_id }}",
            "channel_id": "={{ $('Check User Found').item.json.channel_id }}",
            "thread_ts": "={{ $('Check User Found').item.json.thread_ts }}",
            "response_type": "={{ $('Check User Found').item.json.response_type }}"
          }
        },
        "options": {}
      },
      "id": "send-unauthorized",
      "name": "Send Unauthorized Response",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1880,
        540
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "Cu7YnA1ZgLBjzSvr"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "user": "={{ $json.user }}"
          }
        },
        "options": {}
      },
      "id": "get-personality",
      "name": "Get Personality",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1376,
        348
      ]
    },
    {
      "parameters": {
        "jsCode": "const personalityData = $('Get Personality').first().json;\nconst contextData = $('Route by Auth').first().json;\n\nconst systemPrompt = personalityData.system_prompt;\n\n// Get user timezone for display only\nconst userTimezone = contextData.user.preferences?.timezone || 'America/Chicago';\n\n// Extract mentioned users from the message for context\nconst mentionedUserIds = contextData.mentioned_user_ids || [];\nconst mentionedUsersInfo = mentionedUserIds.length > 0\n  ? `\\n\\nMENTIONED USERS IN THIS MESSAGE:\\nThe following Slack user IDs were @mentioned: ${mentionedUserIds.join(', ')}\\nYou MUST look up these users using list_users before taking any action involving them. NEVER guess their email.`\n  : '';\n\nconst toolInstructions = `\n\n##############################################\n# COMPLEX TASK COORDINATOR\n##############################################\n\nYou handle COMPLEX tasks that require coordination, creativity, or multi-step execution.\nSimple utility tasks (single calendar lookups, quick emails) are handled elsewhere.\n\nYou have exactly 4 tools:\n\n1. marketing_team - Content creation specialists\n   - ALL social media content (LinkedIn, Twitter, Facebook, Instagram)\n   - ALL blog posts and marketing content\n   - Brand guidelines compliance and editorial review\n   - Use for ANY creative content that will be published\n\n2. utility_worker - Your execution arm for ALL data operations\n   - Calendar: summaries, event lookups, scheduling, daily briefs, agendas\n   - Email: search, draft, send, inbox lookups\n   - Documents: creation, reading, updating\n   - Sheets: reading, writing, analysis\n   - Drive: file operations\n   - ANY task requiring Gmail, Calendar, Docs, Sheets, or Drive\n   - You do NOT have these tools directly \u2014 utility_worker does\n   - ALWAYS delegate data operations to utility_worker, never respond from memory\n\n3. list_users - Quick user lookups\n   - Use BEFORE delegating tasks involving people\n   - Get verified email addresses for @mentioned users\n\n4. web_search - Information gathering\n   - Research before content creation\n   - Current events and real-time information\n\n##############################################\n# EXECUTION MANDATE\n##############################################\n\nABSOLUTE RULE: When the user requests an action, you MUST attempt it.\n\nYou are a coordinator. Your job is to route requests to tools and\nreport results. You do NOT decide whether a tool \"works\" \u2014 you call\nit and let the result speak for itself.\n\nNEVER DO THIS:\n- Refuse to call a tool because it failed in a previous conversation\n- Tell the user a tool is \"broken\" based on your memory\n- Offer to do work yourself instead of delegating to the right team\n- Second-guess the user's explicit instruction based on past experience\n- Respond with data from MEMORY when a tool can fetch LIVE data\n- Say \"I don't have access to X\" when utility_worker CAN access X\n\nALWAYS DO THIS:\n- Route the request to the correct tool per the routing rules below\n- If the tool returns an error THIS time, report that specific error\n- If the tool succeeds, report the success\n\nMemory is for conversational context (preferences, names, prior topics).\nMemory is NOT for predicting tool outcomes. Tools are maintained and\nupdated between conversations. Past failures are irrelevant to the\ncurrent request.\n\nThe user's instruction overrides everything. If they say \"do it again,\"\nyou do it again.\n\n##############################################\n# ROUTING RULES (CRITICAL \u2014 FOLLOW EXACTLY)\n##############################################\n\nUTILITY_WORKER \u2014 Use for ALL data/tool operations:\n- \"daily brief\" / \"morning summary\" / \"agenda\" / \"schedule\" \u2192 utility_worker\n- ANY calendar request (events, meetings, availability) \u2192 utility_worker\n- ANY email request (inbox, send, draft, lookup) \u2192 utility_worker\n- ANY document or spreadsheet operation \u2192 utility_worker\n- ANY request that needs live data you cannot access directly \u2192 utility_worker\n- When in doubt whether you need data \u2192 call utility_worker\n\nMARKETING_TEAM \u2014 Use for content creation:\n- \"Create a LinkedIn post about...\" \u2192 marketing_team\n- \"Write a blog post on...\" \u2192 marketing_team\n- \"Draft social media content for...\" \u2192 marketing_team\n- \"Create marketing copy for...\" \u2192 marketing_team\n- ANY request for publishable content \u2192 marketing_team\n\nHANDLE DIRECTLY (no tool needed):\n- User lookups \u2192 list_users\n- Quick research questions \u2192 web_search\n- Clarifying questions \u2192 respond directly\n- Greetings and conversation \u2192 respond directly\n\n##############################################\n# EXECUTION RULES\n##############################################\n\nRULE #1 - DELEGATE EXECUTION:\n- You coordinate, you don't execute utility operations directly\n- You do NOT have Gmail, Calendar, Docs, Sheets tools\n- All utility execution goes through utility_worker\n- NEVER say \"I don't have access to your calendar\" \u2014 delegate to utility_worker instead\n\nRULE #2 - LOOKUP BEFORE DELEGATING:\n- If task involves @mentioned users, call list_users FIRST\n- Pass verified user info to your workers\n\nRULE #3 - PROVIDE COMPLETE CONTEXT:\n- When delegating, include ALL relevant context\n- User timezone, preferences, specific requirements\n- The more context, the better the result\n\nRULE #4 - KEEP RESPONSES CONCISE:\n- Under 2000 characters for Slack\n- Summarize worker results clearly\n\n##############################################\n# FAILURE TRANSPARENCY (CRITICAL)\n##############################################\n\nWhen a tool call FAILS or returns an error, you MUST be transparent:\n\n1. MARKETING_TEAM FAILURE:\n   - ALWAYS tell the user the marketing pipeline encountered an issue\n   - SANITIZE the error \u2014 never show raw node names, stack traces, or n8n internals to the user\n   - Do NOT silently fall back to utility_worker to write content\n   - Instead, explain: \"The marketing team ran into a technical issue.\n     I can draft something quick using the utility worker, but it won't\n     go through the full review pipeline (no editorial review, no image\n     generation, no calendar tracking). Want me to proceed with a quick\n     draft, or would you prefer I try the marketing team again?\"\n   - If the user says yes to quick draft, proceed with utility_worker\n     but prefix the response with a note that it's an unreviewed draft\n\n2. UTILITY_WORKER FAILURE:\n   - Report the error to the user\n   - Suggest they try again or rephrase\n\n3. GENERAL RULE:\n   - Never pretend a degraded result is the full result\n   - The user deserves to know when they're getting a fallback\n   - A transparent failure is better than a silent degradation\n\n##############################################\n# EXAMPLE COMPLEX TASK FLOWS\n##############################################\n\nUser: \"Create a LinkedIn post about our Q4 results\"\n\u2192 Call marketing_team with content brief\n\nUser: \"What's on my calendar today?\" / \"Daily brief\"\n\u2192 Call utility_worker to fetch calendar and format summary\n\nUser: \"Research competitor pricing and draft a comparison email to the team\"\n\u2192 1) Call web_search for competitor pricing\n\u2192 2) Call utility_worker to draft and send email with research\n\nUser: \"Set up a meeting with @john and @sarah about the project\"\n\u2192 1) Call list_users to get John and Sarah's info\n\u2192 2) Call utility_worker to coordinate calendars and send invites\n\nUser: \"Write a blog post about AI trends\"\n\u2192 1) Call web_search for current AI trends\n\u2192 2) Call marketing_team with research context\n\n##############################################`;\n\n\n// Fetch thread history if available (thread reply path)\nlet threadContext = '';\nlet isThreadReply = false;\ntry {\n  const fetchResult = $('Fetch Thread History').first().json;\n  if (fetchResult && fetchResult.ok && Array.isArray(fetchResult.messages)) {\n    isThreadReply = true;\n    const threadMessages = fetchResult.messages;\n\n    if (threadMessages.length > 0) {\n      const formatted = threadMessages.map(msg => {\n        const isBot = !!msg.bot_id;\n        const sender = isBot ? 'Alfred (you)' : `<@${msg.user}>`;\n        const time = new Date(parseFloat(msg.ts) * 1000).toISOString();\n        const text = (msg.text || '').substring(0, 500);\n        return `[${time}] ${sender}: ${text}`;\n      }).join('\\n');\n\n      threadContext = `\\n\\n##############################################\\n# THREAD CONTEXT\\n##############################################\\n\\nThis message is a reply in an existing thread. Here is the full conversation history:\\n\\n${formatted}\\n\\nThe user's latest message (your current task) is the last entry above.\\nUse this thread context to understand what was previously discussed and what action the user is requesting now.`;\n    }\n  }\n} catch (e) {\n  // Not a thread reply - Fetch Thread History did not execute\n}\n\n// =============================================================================\n// PROACTIVE/SCHEDULED TASK CONTEXT\n// When triggered by a scheduled task (not a user message), instruct the LLM\n// to treat this as a proactive deliverable, not a reactive response.\n// =============================================================================\nconst triggerType = contextData.trigger_type || 'user';\nlet proactiveContext = '';\nif (triggerType === 'subworkflow') {\n  proactiveContext = `\\n\\n##############################################\\n# PROACTIVE TASK CONTEXT (CRITICAL)\\n##############################################\\n\\nThis message was triggered by an AUTOMATED SCHEDULED TASK, NOT a direct\\nuser request. The user did NOT just ask you for this \u2014 you are delivering\\na scheduled output as part of your core role and responsibilities.\\n\\nTREAT THIS AS: A team member proactively sending a deliverable to their\\nboss. You are reaching out unprompted because this is YOUR job.\\n\\nCRITICAL RULES FOR PROACTIVE MESSAGES:\\n- DO NOT use reactive phrases: \\\"Already done.\\\", \\\"I know.\\\", \\\"You're welcome.\\\",\\n  \\\"Here you go.\\\", \\\"As requested.\\\", \\\"Sure!\\\", \\\"Of course!\\\" \u2014 nobody asked.\\n- DO NOT write as if responding to a question or command.\\n- DO write as if sending an expected deliverable to your principal.\\n- Lead with a warm, personality-consistent greeting appropriate for the\\n  time of day and the nature of the deliverable.\\n- The personality style still applies for tone and flair, but adapt it\\n  for PROACTIVE delivery \u2014 you are initiating, not reacting.`;\n}\n\nconst fullSystemContext = `${systemPrompt}${toolInstructions}${mentionedUsersInfo}${threadContext}${proactiveContext}\n\nUser Information:\n- Name: ${contextData.user.slack_username}\n- Email: ${contextData.user.email}\n- Role: ${contextData.user.role}\n- Timezone: ${userTimezone}\n- Current Personality: ${personalityData.personality_name}\n\nEmail Approval:\n- All outbound emails require user approval before sending\n- When utility_worker sends an email, an approval card will appear in Slack\n- The user must click \"Send\" to actually send the email\n\nResponse Type: ${contextData.response_type}`;\n\nreturn [{\n  json: {\n    ...contextData,\n    system_context: fullSystemContext,\n    user_request: contextData.message_text,\n    personality_name: personalityData.personality_name,\n    personality_key: personalityData.personality_key,\n    is_thread_reply: isThreadReply\n  }\n}];"
      },
      "id": "build-context",
      "name": "Build Agent Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1880,
        348
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.user_request }}",
        "needsFallback": true,
        "options": {
          "systemMessage": "={{ $json.system_context }}",
          "maxIterations": 10,
          "returnIntermediateSteps": true
        }
      },
      "id": "ai-agent",
      "name": "Alfred AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        3536,
        96
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "claude-sonnet-4-5-20250929",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "id": "ai-model",
      "name": "Claude Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        3224,
        320
      ],
      "credentials": {
        "anthropicApi": {
          "id": "iKUsIHimnjBUibjJ",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Build Agent Context').item.json.slack_user_id }}",
        "tableName": "alfred_chat_history",
        "contextWindowLength": 10
      },
      "id": "chat-memory",
      "name": "Chat Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        3480,
        320
      ],
      "credentials": {
        "postgres": {
          "id": "8nTSHxonyIBczkvN",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const agentOutput = $input.first().json;\nconst context = $('Build Agent Context').first().json;\n\nconst responseText = agentOutput.output || agentOutput.text || 'I apologize, but I encountered an issue processing your request.';\n\n// Pass through notified_event_ids from Utility Worker path (if present)\nconst notifiedEventIds = agentOutput.notified_event_ids || [];\n\nreturn [{\n  json: {\n    response_text: responseText,\n    slack_user_id: context.slack_user_id,\n    channel_id: context.channel_id,\n    thread_ts: context.thread_ts,\n    response_type: context.response_type,\n    user: context.user,\n    original_request: context.message_text,\n    personality_name: context.personality_name,\n    notified_event_ids: notifiedEventIds\n  }\n}];"
      },
      "id": "format-response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4424,
        348
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "aPGhgQ2p6A7aygUt"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "response_text": "={{ $('Format Response').first().json.response_text }}",
            "slack_user_id": "={{ $('Format Response').first().json.slack_user_id }}",
            "channel_id": "={{ $('Format Response').first().json.channel_id }}",
            "thread_ts": "={{ $('Format Response').first().json.thread_ts }}",
            "response_type": "={{ $('Format Response').first().json.response_type }}"
          }
        },
        "options": {}
      },
      "id": "send-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        5096,
        276
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "Ui3uhPgKsfXVnIss"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "slack_user_id": "={{ $('Format Response').item.json.slack_user_id }}",
            "action": "chat",
            "resource": "ai_agent",
            "permitted": true,
            "denial_reason": "",
            "request_summary": "={{ $('Format Response').item.json.original_request }}",
            "metadata": "={{ {response_length: $('Format Response').item.json.response_text?.length || 0, personality: $('Format Response').item.json.personality_name} }}"
          }
        },
        "options": {}
      },
      "id": "log-action",
      "name": "Log Action",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        5768,
        348
      ]
    },
    {
      "parameters": {
        "description": "List all users registered in the Alfred system. Shows their Slack username, email, role, timezone, and Google auth status. Only admins can list users.",
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "DIr3sLVyRlkgm4lu"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "slack_user_id": "",
            "action": "list_users",
            "role": "",
            "timezone_override": "",
            "requesting_user_id": "={{ $('Normalize Input').item.json.slack_user_id }}"
          },
          "schema": [
            {
              "id": "slack_user_id",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "slack_user_id"
            },
            {
              "id": "action",
              "type": "string",
              "display": true,
              "required": true,
              "displayName": "action"
            },
            {
              "id": "role",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "role"
            },
            {
              "id": "timezone_override",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "timezone_override"
            },
            {
              "id": "requesting_user_id",
              "type": "string",
              "display": true,
              "required": true,
              "displayName": "requesting_user_id"
            }
          ]
        }
      },
      "id": "tool-list-users",
      "name": "Tool: List Users",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        3736,
        320
      ]
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "slack_user_id"
            },
            {
              "name": "message"
            },
            {
              "name": "channel_id"
            },
            {
              "name": "thread_ts"
            },
            {
              "name": "response_type"
            }
          ]
        }
      },
      "id": "subworkflow-trigger",
      "name": "Sub-workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        256,
        540
      ]
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\n\n// Format sub-workflow input to match Slack trigger normalized output\n// Guard against missing fields to prevent downstream Postgres crashes\nreturn [{\n  json: {\n    slack_user_id: input.slack_user_id || '',\n    channel_id: input.channel_id || '',\n    thread_ts: input.thread_ts || '',\n    message_text: input.message || '',\n    mentioned_user_ids: [],\n    trigger_type: 'subworkflow',\n    response_type: input.response_type || 'dm',\n    raw_event: { source: 'subworkflow' }\n  }\n}];"
      },
      "id": "normalize-subworkflow",
      "name": "Normalize Sub-workflow Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        540
      ]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5.2",
          "mode": "list",
          "cachedResultName": "gpt-5.2"
        },
        "builtInTools": {},
        "options": {}
      },
      "id": "fallback-model",
      "name": "GPT-5.2 Fallback",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        3352,
        320
      ],
      "credentials": {
        "openAiApi": {
          "id": "K0dJSGlrxig3qa2p",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "predicate-result",
              "leftValue": "={{ $json.result }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-no-send",
      "name": "Check Should Send",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        4872,
        348
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get context from upstream\nconst context = $('Build Agent Context').first().json;\nconst errorData = $input.first().json;\n\n// Extract error message if available\nlet errorMessage = 'an unexpected issue';\nif (errorData.error?.message) {\n  const msg = errorData.error.message.toLowerCase();\n  if (msg.includes('timeout')) {\n    errorMessage = 'the request took too long';\n  } else if (msg.includes('rate limit')) {\n    errorMessage = 'too many requests right now';\n  } else if (msg.includes('credential') || msg.includes('auth')) {\n    errorMessage = 'a connection issue with one of my tools';\n  } else if (msg.includes('schema') || msg.includes('validation')) {\n    errorMessage = 'trouble understanding the request format';\n  }\n}\n\n// Create friendly error response\nconst friendlyResponse = `I ran into ${errorMessage} while working on that. Could you try asking again in a moment? If this keeps happening, let Spencer know.`;\n\nreturn [{\n  json: {\n    output: friendlyResponse,\n    error: true,\n    errorDetails: errorData.error || null\n  }\n}];"
      },
      "id": "error-handler",
      "name": "Handle Agent Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4200,
        128
      ]
    },
    {
      "parameters": {
        "description": "Search the web for current information, news, and real-time data. Use this when you need up-to-date information that may not be in your training data. Returns results with cited sources.",
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "F0TUHVEzA79rroyS"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ $fromAI(\"query\", \"The search query to look up on the web\", \"string\", \"\") }}",
            "context": "={{ $fromAI(\"context\", \"Optional additional context to improve search results\", \"string\", \"\") }}",
            "allowed_domains": "={{ $fromAI(\"allowed_domains\", \"Optional comma-separated list of domains to limit search to\", \"string\", \"\") }}"
          },
          "schema": [
            {
              "id": "query",
              "type": "string",
              "display": true,
              "required": true,
              "displayName": "query"
            },
            {
              "id": "context",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "context"
            },
            {
              "id": "allowed_domains",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "allowed_domains"
            }
          ],
          "matchingColumns": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "id": "tool-web-search",
      "name": "Tool: Web Search",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        3864,
        320
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "Rw7786cYTYOTQhH9"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "predicate": "Return TRUE if the response provides value to the user. This includes: (1) Specific actionable content like meeting details, calendar events, requested data, (2) Error messages or technical issues the user needs to know about, (3) Clarifying questions that require user input, (4) Status updates on requested tasks, (5) Any substantive response to what the user asked for. Return FALSE ONLY for: (1) Generic task confirmations like 'Task completed', 'Done', 'OK' with no other content, (2) When a scheduled/automated task found nothing to report AND the original request explicitly said 'do not send any message' in that case. When in doubt, return TRUE - it's better to inform the user than leave them waiting.",
            "context": "={{ JSON.stringify({ response: $json.response_text, original_request: $json.original_request }) }}",
            "fallback": "true"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "predicate",
              "displayName": "predicate",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "context",
              "displayName": "context",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "fallback",
              "displayName": "fallback",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "evaluate-predicate",
      "name": "Evaluate Predicate",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        4648,
        348
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "loose"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "check-success",
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "check-send-success",
      "name": "Check Send Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        5320,
        276
      ]
    },
    {
      "parameters": {
        "jsCode": "const sendResult = $input.first().json;\nconst formatResponse = $('Format Response').first().json;\n\nconst errorDetails = {\n  action: sendResult.action || 'unknown',\n  error: sendResult.error || 'unknown_error',\n  error_detail: sendResult.error_detail || [],\n  slack_user_id: formatResponse.slack_user_id,\n  response_type: formatResponse.response_type,\n  channel_id: formatResponse.channel_id,\n  response_text_preview: (formatResponse.response_text || '').substring(0, 100)\n};\n\nthrow new Error(`Slack delivery failed: ${errorDetails.error}. Details: ${JSON.stringify(errorDetails.error_detail)}. User: ${errorDetails.slack_user_id}`);"
      },
      "id": "handle-send-failure",
      "name": "Handle Send Failure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5544,
        348
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "Rw7786cYTYOTQhH9"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "predicate": "isComplex",
            "context": "={{ JSON.stringify({ user_request: $json.user_request, complexity_rule: 'A request is COMPLEX only if it requires SPECIALTY KNOWLEDGE (marketing, content creation, brand guidelines) OR if it requires coordinating MULTIPLE DIFFERENT services in sequence where output from one feeds into another (e.g., web search then draft email then send). A request is SIMPLE if it primarily needs data from a single service (calendar, email, docs, sheets) and formats the result even if the output has specific formatting, personality, or analytical requirements. Daily briefs, calendar summaries, email lookups, and document reads are ALWAYS SIMPLE. When in doubt, classify as SIMPLE.' }) }}",
            "fallback": "true"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "predicate",
              "displayName": "predicate",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "context",
              "displayName": "context",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "fallback",
              "displayName": "fallback",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "classify-task-complexity",
      "name": "Classify Task Complexity",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2104,
        348
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "or",
          "conditions": [
            {
              "id": "classifier-says-complex",
              "leftValue": "={{ $json.result }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            },
            {
              "id": "thread-reply-always-complex",
              "leftValue": "={{ !!($('Build Agent Context').first().json.raw_event?.thread_ts && $('Build Agent Context').first().json.raw_event.thread_ts !== $('Build Agent Context').first().json.raw_event.ts) }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "route-by-complexity",
      "name": "Route by Complexity",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2328,
        348
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get context from Build Agent Context\nconst context = $('Build Agent Context').first().json;\nconst message = context.user_request.toLowerCase();\n\n// Parse user message for iteration intent phrases\nlet user_iteration_override = null;\n\nif (message.includes('iterate until perfect') || message.includes('keep refining') || message.includes('keep iterating')) {\n  user_iteration_override = 10;\n} else if (message.includes('no revisions') || message.includes('quick draft') || message.includes('just one draft') || message.includes('no iterations')) {\n  user_iteration_override = 0;\n} else {\n  // Check for explicit iteration count\n  const match = message.match(/(\\d+)\\s*(revision|iteration|round|draft)/i);\n  if (match) {\n    user_iteration_override = parseInt(match[1]);\n  }\n}\n\n// Thread reply flag (already set by Build Agent Context)\nconst isThreadReply = context.is_thread_reply || false;\n\nreturn [{\n  json: {\n    ...context,\n    user_iteration_override: user_iteration_override,\n    is_complex_task: true,\n    is_thread_reply: isThreadReply\n  }\n}];"
      },
      "id": "parse-iteration-override",
      "name": "Parse Iteration Override",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3000,
        200
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "yXnjcopPZfdrzMzs"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "task_prompt": "={{ $('Build Agent Context').item.json.user_request }}",
            "user_context": "={{ JSON.stringify({ user: $('Build Agent Context').item.json.user, personality_name: $('Build Agent Context').item.json.personality_name }) }}",
            "slack_context": "={{ JSON.stringify({ slack_user_id: $('Build Agent Context').item.json.slack_user_id, channel_id: $('Build Agent Context').item.json.channel_id, thread_ts: $('Build Agent Context').item.json.thread_ts, response_type: $('Build Agent Context').item.json.response_type }) }}",
            "session_id": "={{ $('Build Agent Context').item.json.slack_user_id }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "task_prompt",
              "displayName": "task_prompt",
              "required": true,
              "display": true,
              "type": "string"
            },
            {
              "id": "user_context",
              "displayName": "user_context",
              "required": false,
              "display": true,
              "type": "string"
            },
            {
              "id": "slack_context",
              "displayName": "slack_context",
              "required": false,
              "display": true,
              "type": "string"
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "display": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "call-utility-worker",
      "name": "Call Utility Worker",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3600,
        496
      ]
    },
    {
      "parameters": {
        "description": "Create marketing content including blog posts, social media posts (LinkedIn, Twitter, Facebook), and marketing briefs. Use for content creation tasks requiring ideation, writing, and review cycles. Specify target_channels as array. Supports iteration control with user preferences.",
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "WUNHfC0c2FRgIlye"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "task_prompt": "={{ $fromAI(\"task_prompt\", \"The content creation task to execute\", \"string\", \"\") }}",
            "target_channels": "={{ $fromAI(\"target_channels\", \"JSON array of target channels: linkedin, facebook, twitter, blog\", \"string\", \"\") }}",
            "user_context": "={{ JSON.stringify({ user: $('Build Agent Context').item.json.user, personality_name: $('Build Agent Context').item.json.personality_name }) }}",
            "slack_context": "={{ JSON.stringify({ slack_user_id: $('Build Agent Context').item.json.slack_user_id, channel_id: $('Build Agent Context').item.json.channel_id, thread_ts: $('Build Agent Context').item.json.thread_ts, response_type: $('Build Agent Context').item.json.response_type }) }}",
            "team_config": "={{ JSON.stringify({ max_iterations: 3, user_iteration_override: $('Parse Iteration Override').item.json.user_iteration_override || null }) }}"
          },
          "schema": [
            {
              "id": "task_prompt",
              "type": "string",
              "display": true,
              "required": true,
              "displayName": "task_prompt"
            },
            {
              "id": "target_channels",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "target_channels"
            },
            {
              "id": "user_context",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "user_context"
            },
            {
              "id": "slack_context",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "slack_context"
            },
            {
              "id": "team_config",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "team_config"
            }
          ],
          "matchingColumns": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "id": "tool-marketing-team",
      "name": "Tool: Marketing Team",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        3608,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format Utility Worker response for standard output\nconst utilityResult = $input.first().json;\nconst context = $('Build Agent Context').first().json;\n\n// Check for failure first\nif (utilityResult.success === false) {\n  const errorMsg = utilityResult.error || 'Something went wrong with that request.';\n  return [{\n    json: {\n      output: errorMsg,\n      notified_event_ids: []\n    }\n  }];\n}\n\n// Utility Worker returns: { success, result, error?, notified_event_ids? }\nconst responseText = utilityResult.result || utilityResult.output || utilityResult.response || 'Task completed.';\n\nreturn [{\n  json: {\n    output: responseText,\n    notified_event_ids: utilityResult.notified_event_ids || []\n  }\n}];"
      },
      "id": "format-utility-response",
      "name": "Format Utility Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4200,
        496
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "r620xYkkbiShXhxp"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "user_request": "={{ $('Build Agent Context').item.json.user_request }}",
            "personality_prompt": "={{ $('Get Personality').item.json.system_prompt }}",
            "slack_context": "={{ JSON.stringify({ slack_user_id: $('Build Agent Context').item.json.slack_user_id, channel_id: $('Build Agent Context').item.json.channel_id, thread_ts: $('Build Agent Context').item.json.thread_ts, response_type: $('Build Agent Context').item.json.response_type }) }}"
          },
          "schema": [
            {
              "id": "user_request",
              "type": "string",
              "display": true,
              "required": true,
              "displayName": "user_request"
            },
            {
              "id": "personality_prompt",
              "type": "string",
              "display": true,
              "required": true,
              "displayName": "personality_prompt"
            },
            {
              "id": "slack_context",
              "type": "string",
              "display": true,
              "required": true,
              "displayName": "slack_context"
            }
          ],
          "matchingColumns": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "id": "send-auto-ack",
      "name": "Send Auto Ack",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2776,
        128
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "trigger-check",
              "leftValue": "={{ $('Build Agent Context').item.json.trigger_type }}",
              "rightValue": "subworkflow",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-is-user-request",
      "name": "Is User Request?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2552,
        200
      ]
    },
    {
      "parameters": {
        "description": "Delegate routine utility tasks to the Utility Worker. Use for: email operations (draft, send), calendar management, Google Docs/Sheets operations, Slack messaging to others, web searches, user management, preference updates. The Utility Worker has its own memory and tool access. Provide clear instructions and context.",
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "yXnjcopPZfdrzMzs"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "task_prompt": "={{ $fromAI(\"task_prompt\", \"The task for the Utility Worker to execute\", \"string\", \"\") }}",
            "user_context": "={{ JSON.stringify({ user: $('Build Agent Context').item.json.user, personality_name: $('Build Agent Context').item.json.personality_name }) }}",
            "slack_context": "={{ JSON.stringify({ slack_user_id: $('Build Agent Context').item.json.slack_user_id, channel_id: $('Build Agent Context').item.json.channel_id, thread_ts: $('Build Agent Context').item.json.thread_ts, response_type: $('Build Agent Context').item.json.response_type }) }}",
            "session_id": "={{ $('Build Agent Context').item.json.slack_user_id }}"
          },
          "schema": [
            {
              "id": "task_prompt",
              "type": "string",
              "display": true,
              "required": true,
              "displayName": "task_prompt"
            },
            {
              "id": "user_context",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "user_context"
            },
            {
              "id": "slack_context",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "slack_context"
            },
            {
              "id": "session_id",
              "type": "string",
              "display": true,
              "required": false,
              "displayName": "session_id"
            }
          ],
          "matchingColumns": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        }
      },
      "id": "tool-utility-worker",
      "name": "Tool: Utility Worker",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        3992,
        320
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "thread-reply-check",
              "leftValue": "={{ $('Route by Auth').first().json.response_type === 'thread' }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "is-thread-reply",
      "name": "Is Thread Reply?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1520,
        348
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://slack.com/api/conversations.replies",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "slackApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "channel",
              "value": "={{ $('Route by Auth').first().json.channel_id }}"
            },
            {
              "name": "ts",
              "value": "={{ $('Route by Auth').first().json.thread_ts }}"
            },
            {
              "name": "inclusive",
              "value": "true"
            },
            {
              "name": "limit",
              "value": "50"
            }
          ]
        }
      },
      "id": "fetch-thread-history",
      "name": "Fetch Thread History",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1660,
        180
      ],
      "onError": "continueRegularOutput",
      "credentials": {
        "slackApi": {
          "id": "apG1iXE1E50lr9RH",
          "name": "Slack account"
        }
      }
    },
    {
      "id": "lookup-thread-approval",
      "name": "Lookup Thread Approval",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1660,
        -50
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, action_type, status, payload, slack_user_id, slack_channel_id, slack_thread_ts, approval_message_ts, created_at, expires_at\nFROM alfred.pending_actions\nWHERE slack_thread_ts = $1\n  AND status = 'pending'\n  AND action_type = 'publish_content'\nORDER BY created_at DESC\nLIMIT 1",
        "options": {
          "queryReplacement": "={{ [$('Route by Auth').first().json.thread_ts || ''] }}"
        }
      },
      "credentials": {
        "postgres": {
          "id": "8nTSHxonyIBczkvN",
          "name": "Postgres account"
        }
      },
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "id": "check-text-approval",
      "name": "Check Text Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1840,
        -50
      ],
      "parameters": {
        "jsCode": "const lookupResult = $('Lookup Thread Approval').first().json;\nconst context = $('Route by Auth').first().json;\n\n// Get the user's message\nconst userMessage = (context.raw_event?.text || context.text || '').toLowerCase().trim();\n\n// Remove bot mentions from message for cleaner intent detection\nconst cleanMessage = userMessage.replace(/<@[A-Z0-9]+>/g, '').trim();\n\n// Check if there's a pending publish_content action in this thread\nconst hasPendingAction = !!(lookupResult && lookupResult.id && lookupResult.status === 'pending');\n\nlet isApproval = false;\n\nif (hasPendingAction) {\n  // Approval keywords/patterns\n  const approvalPatterns = [\n    /\\bapprov(e|ed|al|ing)\\b/i,\n    /\\b(yes|yep|yeah|yea|y)\\b/i,\n    /\\blooks?\\s+good\\b/i,\n    /\\blgtm\\b/i,\n    /\\bgo\\s+(ahead|for\\s+it)\\b/i,\n    /\\b(post|publish|ship)\\s+(it|this|that|them)\\b/i,\n    /\\bpost\\s+to\\s+(the\\s+)?calendar\\b/i,\n    /\\bgood\\s+to\\s+go\\b/i,\n    /\\bthumb(s)?\\s+up\\b/i,\n    /\\ud83d\\udc4d/,\n    /\\bconfirm(ed)?\\b/i,\n    /\\baccept(ed)?\\b/i,\n    /\\bdo\\s+it\\b/i,\n    /\\bsend\\s+it\\b/i,\n    /\\blet'?s\\s+go\\b/i,\n  ];\n\n  // Negation patterns (don't approve if these are present alongside approval words)\n  const negationPatterns = [\n    /\\b(but|however|wait|hold|before|don't|do\\s+not|change|modify|revise|edit|fix|update|redo|tweak)\\b/i,\n    /\\bnot\\s+(yet|ready|sure|quite)\\b/i,\n    /\\bcan\\s+you\\s+(change|fix|update|modify|revise|edit)/i,\n    /\\bfirst\\b/i,\n    /\\binstead\\b/i,\n  ];\n\n  const hasApprovalKeyword = approvalPatterns.some(p => p.test(cleanMessage));\n  const hasNegation = negationPatterns.some(p => p.test(cleanMessage));\n\n  // Short messages with approval keywords are almost certainly approvals\n  const wordCount = cleanMessage.split(/\\s+/).filter(w => w).length;\n  if (hasApprovalKeyword && !hasNegation) {\n    isApproval = true;\n  } else if (hasApprovalKeyword && hasNegation && wordCount <= 3) {\n    // Very short message with approval word wins even if negation detected\n    // e.g., \"yes, approved\" where \"but\" isn't present\n    isApproval = true;\n  }\n}\n\n// Parse the pending action payload\nlet payload = {};\nif (hasPendingAction && lookupResult.payload) {\n  payload = lookupResult.payload;\n  if (typeof payload === 'string') {\n    try { payload = JSON.parse(payload); } catch (e) { payload = {}; }\n  }\n}\n\nreturn [{\n  json: {\n    is_approval: isApproval,\n    has_pending_action: hasPendingAction,\n    pending_action_id: lookupResult?.id || null,\n    pending_action: hasPendingAction ? lookupResult : null,\n    payload: payload,\n    user_message: cleanMessage,\n    slack_user_id: context.slack_user_id || context.raw_event?.user,\n    channel_id: context.channel_id,\n    thread_ts: context.raw_event?.thread_ts,\n    approval_message_ts: lookupResult?.approval_message_ts || null\n  }\n}];"
      }
    },
    {
      "id": "route-text-approval",
      "name": "Route Text Approval",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2020,
        -50
      ],
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "check-is-approval",
              "leftValue": "={{ $json.is_approval }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      }
    },
    {
      "id": "approve-in-db",
      "name": "Approve in DB",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2200,
        -250
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE alfred.pending_actions\nSET\n  status = 'approved',\n  resolved_at = NOW(),\n  resolved_by_slack_user_id = $1,\n  resolution_note = 'Approved via text message in thread'\nWHERE id = $2::uuid\n  AND status = 'pending'\nRETURNING *;",
        "options": {
          "queryReplacement": "={{ [$('Check Text Approval').first().json.slack_user_id, $('Check Text Approval').first().json.pending_action_id] }}"
        }
      },
      "credentials": {
        "postgres": {
          "id": "8nTSHxonyIBczkvN",
          "name": "Postgres account"
        }
      }
    },
    {
      "id": "prepare-calendar-update",
      "name": "Prepare Calendar Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2860,
        -250
      ],
      "parameters": {
        "jsCode": "const approval = $('Check Text Approval').first().json;\nconst payload = approval.payload;\n\nreturn [{\n  json: {\n    slack_user_id: approval.slack_user_id,\n    action: 'update_tracker',\n    drafts: JSON.stringify(payload.drafts || {}),\n    images: '{}',\n    winning_idea: payload.post_summary || '',\n    target_channels: payload.target_channels || payload.content_type || '',\n    channel_id: approval.channel_id,\n    thread_ts: approval.thread_ts,\n    approval_message_ts: approval.approval_message_ts,\n    pending_action: approval.pending_action\n  }\n}];"
      }
    },
    {
      "id": "update-content-calendar",
      "name": "Update Content Calendar",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3080,
        -250
      ],
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "ezvCaPeNM8P7gEWj"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "action": "update_tracker",
            "slack_user_id": "={{ $json.slack_user_id }}",
            "drafts": "={{ $json.drafts }}",
            "images": "={{ $json.images }}",
            "winning_idea": "={{ $json.winning_idea }}",
            "target_channels": "={{ $json.target_channels }}"
          }
        },
        "options": {}
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "update-approval-card",
      "name": "Update Approval Card",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3520,
        -250
      ],
      "parameters": {
        "method": "POST",
        "url": "https://slack.com/api/chat.update",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "slackApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"channel\": \"{{ $('Prepare Calendar Update').first().json.channel_id }}\",\n  \"ts\": \"{{ $('Prepare Calendar Update').first().json.approval_message_ts }}\",\n  \"blocks\": [\n    {\n      \"type\": \"header\",\n      \"text\": { \"type\": \"plain_text\", \"text\": \"\\u2705 Content Approved\", \"emoji\": true }\n    },\n    {\n      \"type\": \"section\",\n      \"fields\": [\n        { \"type\": \"mrkdwn\", \"text\": \"*Topic:*\\n{{ $('Prepare Calendar Update').first().json.winning_idea || 'Content' }}\" },\n        { \"type\": \"mrkdwn\", \"text\": \"*Status:*\\nApproved via text\" }\n      ]\n    },\n    {\n      \"type\": \"context\",\n      \"elements\": [\n        { \"type\": \"mrkdwn\", \"text\": \"\\ud83d\\udcca Calendar updated to *Ready* \\u2022 Approved by <@{{ $('Prepare Calendar Update').first().json.slack_user_id }}>\" }\n      ]\n    }\n  ]\n}",
        "options": {}
      },
      "credentials": {
        "slackApi": {
          "id": "apG1iXE1E50lr9RH",
          "name": "Slack account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "send-approval-confirmation",
      "name": "Send Approval Confirmation",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3740,
        -250
      ],
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "xbFJVyUFvGfUbY4s"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "action": "post_thread",
            "channel_id": "={{ $('Prepare Calendar Update').first().json.channel_id }}",
            "thread_ts": "={{ $('Prepare Calendar Update').first().json.thread_ts }}",
            "text": "\ud83c\udf89 Content approved! Calendar updated to Ready status.",
            "blocks": "={{ [] }}"
          }
        },
        "options": {}
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "record-notified-events",
      "name": "Record Notified Events",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        5544,
        200
      ],
      "credentials": {
        "postgres": {
          "id": "8nTSHxonyIBczkvN",
          "name": "Postgres account"
        }
      },
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ (() => {\n  try {\n    const ids = $('Format Response').first().json.notified_event_ids || [];\n    const userId = $('Format Response').first().json.user?.id || 0;\n    if (!ids.length || !userId) return 'SELECT 1';\n    const values = ids.map(id => `(${userId}, '${id.replace(/'/g, \"''\")}', CURRENT_DATE)`).join(',');\n    return `INSERT INTO alfred.event_notifications (user_id, event_id, notification_date) VALUES ${values} ON CONFLICT (user_id, event_id, notification_date) DO NOTHING`;\n  } catch(e) {\n    return 'SELECT 1';\n  }\n})() }}",
        "options": {}
      },
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "id": "check-calendar-success",
      "name": "Check Calendar Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3300,
        -250
      ],
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "check-cal-success",
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      }
    },
    {
      "id": "format-approval-error",
      "name": "Format Approval Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2860,
        -450
      ],
      "parameters": {
        "jsCode": "const approval = $('Check Text Approval').first().json;\nconst result = $input.first().json;\n\nlet stepName = 'approval process';\nlet errorDetail = result.error || 'An unexpected error occurred';\n\nif (result.output && 'images_generated' in (result.output || {})) {\n  stepName = 'image generation';\n  errorDetail = result.error || 'Failed to generate images for the approved content';\n} else if (result.output && 'tracker_updated' in (result.output || {})) {\n  stepName = 'content calendar update';\n  errorDetail = result.error || 'Failed to update the content calendar';\n}\n\nconst errorMessage = `:warning: Sorry, I ran into an issue during ${stepName} for your approved content.\\n\\n*Error:* ${errorDetail}\\n\\nPlease try approving again or let Spencer know if this keeps happening.`;\n\nreturn [{\n  json: {\n    action: 'post_thread',\n    channel_id: approval.channel_id,\n    thread_ts: approval.thread_ts,\n    text: errorMessage,\n    blocks: []\n  }\n}];"
      }
    },
    {
      "id": "send-approval-error",
      "name": "Send Approval Error",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3080,
        -450
      ],
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "xbFJVyUFvGfUbY4s"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "action": "={{ $json.action }}",
            "channel_id": "={{ $json.channel_id }}",
            "thread_ts": "={{ $json.thread_ts }}",
            "text": "={{ $json.text }}",
            "blocks": "={{ $json.blocks }}"
          }
        },
        "options": {}
      }
    }
  ],
  "connections": {
    "Slack Trigger": {
      "main": [
        [
          {
            "node": "Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Input": {
      "main": [
        [
          {
            "node": "Lookup User",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup User": {
      "main": [
        [
          {
            "node": "Check User Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check User Found": {
      "main": [
        [
          {
            "node": "Route by Auth",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Auth": {
      "main": [
        [
          {
            "node": "Get Personality",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Unauthorized Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Personality": {
      "main": [
        [
          {
            "node": "Is Thread Reply?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unauthorized Response": {
      "main": [
        [
          {
            "node": "Send Unauthorized Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Agent Context": {
      "main": [
        [
          {
            "node": "Classify Task Complexity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classify Task Complexity": {
      "main": [
        [
          {
            "node": "Route by Complexity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Iteration Override": {
      "main": [
        [
          {
            "node": "Alfred AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Utility Worker": {
      "main": [
        [
          {
            "node": "Format Utility Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Utility Response": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tool: Marketing Team": {
      "ai_tool": [
        [
          {
            "node": "Alfred AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Claude Model": {
      "ai_languageModel": [
        [
          {
            "node": "Alfred AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "Alfred AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Alfred AI Agent": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Agent Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Evaluate Predicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tool: List Users": {
      "ai_tool": [
        [
          {
            "node": "Alfred AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Sub-workflow Trigger": {
      "main": [
        [
          {
            "node": "Normalize Sub-workflow Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Sub-workflow Input": {
      "main": [
        [
          {
            "node": "Lookup User",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT-5.2 Fallback": {
      "ai_languageModel": [
        [
          {
            "node": "Alfred AI Agent",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    },
    "Check Should Send": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Agent Error": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tool: Web Search": {
      "ai_tool": [
        [
          {
            "node": "Alfred AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Evaluate Predicate": {
      "main": [
        [
          {
            "node": "Check Should Send",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Response": {
      "main": [
        [
          {
            "node": "Check Send Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Send Success": {
      "main": [
        [
          {
            "node": "Record Notified Events",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Send Failure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is User Request?": {
      "main": [
        [
          {
            "node": "Send Auto Ack",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Iteration Override",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Auto Ack": {
      "main": [
        [
          {
            "node": "Parse Iteration Override",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tool: Utility Worker": {
      "ai_tool": [
        [
          {
            "node": "Alfred AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Route by Complexity": {
      "main": [
        [
          {
            "node": "Is User Request?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call Utility Worker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Send Failure": {
      "main": [
        [
          {
            "node": "Log Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Thread Reply?": {
      "main": [
        [
          {
            "node": "Lookup Thread Approval",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Agent Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Thread History": {
      "main": [
        [
          {
            "node": "Build Agent Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup Thread Approval": {
      "main": [
        [
          {
            "node": "Check Text Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Text Approval": {
      "main": [
        [
          {
            "node": "Route Text Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Text Approval": {
      "main": [
        [
          {
            "node": "Approve in DB",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch Thread History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Calendar Update": {
      "main": [
        [
          {
            "node": "Update Content Calendar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Approval Card": {
      "main": [
        [
          {
            "node": "Send Approval Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Notified Events": {
      "main": [
        [
          {
            "node": "Log Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Content Calendar": {
      "main": [
        [
          {
            "node": "Check Calendar Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Calendar Success": {
      "main": [
        [
          {
            "node": "Update Approval Card",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Approval Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Approval Error": {
      "main": [
        [
          {
            "node": "Send Approval Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Approve in DB": {
      "main": [
        [
          {
            "node": "Prepare Calendar Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "pinData": {
    "Slack Trigger": [
      {
        "json": {
          "type": "message",
          "user": "U02TE7SKU3X",
          "ts": "1770130334.158719",
          "client_msg_id": "deabd3d5-6ce0-4a9f-b685-d858d8896af9",
          "text": "Hey Alfred, what's left on the docket today?'",
          "team": "T02U6T09Z96",
          "blocks": [
            {
              "type": "rich_text",
              "block_id": "uUSNw",
              "elements": [
                {
                  "type": "rich_text_section",
                  "elements": [
                    {
                      "type": "text",
                      "text": "Hey Alfred, what's left on the docket today?'"
                    }
                  ]
                }
              ]
            }
          ],
          "channel": "D0ACCAUC2P8",
          "event_ts": "1770130334.158719",
          "channel_type": "im"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "activeVersionId": "f30c2efe-48cb-4561-bef8-a73ace6c0f72",
  "versionCounter": 509,
  "triggerCount": 1,
  "tags": [
    {
      "updatedAt": "2026-02-02T12:36:24.088Z",
      "createdAt": "2026-02-02T12:36:24.088Z",
      "id": "BMnFlbKzTANo3M1b",
      "name": "AI Agent"
    }
  ],
  "activeVersion": {
    "updatedAt": "2026-02-16T11:42:23.007Z",
    "createdAt": "2026-02-16T11:42:23.007Z",
    "versionId": "f30c2efe-48cb-4561-bef8-a73ace6c0f72",
    "workflowId": "KJpZBr3isT66Rzoa",
    "nodes": [
      {
        "parameters": {
          "trigger": [
            "app_mention",
            "message"
          ],
          "watchWorkspace": true,
          "options": {
            "userIds": [
              "U0AC80Z0HR9"
            ]
          }
        },
        "id": "slack-trigger",
        "name": "Slack Trigger",
        "type": "n8n-nodes-base.slackTrigger",
        "typeVersion": 1,
        "position": [
          256,
          348
        ],
        "webhookId": "819d30ff-6523-479e-bda7-285540d516c7",
        "credentials": {
          "slackApi": {
            "id": "apG1iXE1E50lr9RH",
            "name": "Slack account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const event = $input.first().json;\n\n// Filter out bot messages to prevent Alfred from responding to itself\nconst botId = event.bot_id || event.event?.bot_id;\nconst subtype = event.subtype || event.event?.subtype;\n\nif (botId || subtype === 'bot_message') {\n  // Return empty array to stop workflow execution for bot messages\n  return [];\n}\n\n// Filter out message_changed events (Slack sends these after unfurling links)\n// These cause duplicate executions with different data structure\nif (subtype === 'message_changed' || event.hidden === true) {\n  console.log('[Normalize Input] Filtering out message_changed/hidden event');\n  return [];\n}\n\nconst slackUserId = event.user || event.event?.user;\nconst channelId = event.channel || event.event?.channel;\nconst threadTs = event.thread_ts || event.event?.thread_ts || event.ts || event.event?.ts;\nconst messageText = event.text || event.event?.text || '';\n\n// Only strip the Alfred bot mention, keep other user mentions intact\n// Alfred's bot user ID is U0AC80Z0HR9\nconst cleanedText = messageText.replace(/<@U0AC80Z0HR9>/g, '').trim();\n\n// Extract all user mentions from the message (for tools like create_user)\nconst mentionPattern = /<@([A-Z0-9]+)>/g;\nconst mentions = [];\nlet match;\nwhile ((match = mentionPattern.exec(messageText)) !== null) {\n  // Exclude Alfred's own bot ID\n  if (match[1] !== 'U0AC80Z0HR9') {\n    mentions.push(match[1]);\n  }\n}\n\nlet triggerType = 'unknown';\nif (event.event?.type === 'app_mention') {\n  triggerType = 'mention';\n} else if (event.event?.channel_type === 'im') {\n  triggerType = 'dm';\n} else if (event.channel_type === 'im') {\n  triggerType = 'dm';\n} else {\n  triggerType = 'channel';\n}\n\n// Detect actual thread reply: raw thread_ts differs from message ts\nconst rawTs = event.ts || event.event?.ts;\nconst rawThreadTs = event.thread_ts || event.event?.thread_ts;\nconst isThreadReply = !!(rawThreadTs && rawThreadTs !== rawTs);\n\nlet responseType = 'thread';\nif (triggerType === 'dm' && !isThreadReply) {\n  // New DM (not a thread reply) \u2014 respond as top-level DM\n  responseType = 'dm';\n} else if (isThreadReply) {\n  // Thread reply (in DM or channel) \u2014 respond in-thread\n  responseType = 'thread';\n} else {\n  responseType = 'channel';\n}\n\nreturn [{\n  json: {\n    slack_user_id: slackUserId,\n    channel_id: channelId,\n    thread_ts: threadTs,\n    message_text: cleanedText,\n    mentioned_user_ids: mentions,\n    trigger_type: triggerType,\n    response_type: responseType,\n    raw_event: event\n  }\n}];"
        },
        "id": "normalize-input",
        "name": "Normalize Input",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          480,
          348
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "mHy10eByiuuyr8U1"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "slack_user_id": "={{ $json.slack_user_id }}"
            }
          },
          "options": {}
        },
        "id": "user-lookup",
        "name": "Lookup User",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          704,
          444
        ]
      },
      {
        "parameters": {
          "jsCode": "const lookupResult = $input.first().json;\n\n// Get normalized input - could be from either Slack trigger or sub-workflow\nlet normalizedInput = {};\ntry {\n  normalizedInput = $('Normalize Input').first().json;\n} catch (e) {\n  try {\n    normalizedInput = $('Normalize Sub-workflow Input').first().json;\n  } catch (e2) {\n    // If neither exists, extract what we can from lookup result or use defaults\n    normalizedInput = {\n      slack_user_id: lookupResult.user?.slack_user_id || '',\n      channel_id: '',\n      thread_ts: '',\n      message_text: '',\n      trigger_type: 'subworkflow',\n      response_type: 'dm'\n    };\n  }\n}\n\nlet userData = null;\nlet isFound = false;\n\nif (lookupResult.found === true && lookupResult.user) {\n  userData = lookupResult.user;\n  isFound = true;\n} else if (lookupResult.id && lookupResult.slack_user_id) {\n  userData = lookupResult;\n  isFound = true;\n}\n\nif (isFound && userData) {\n  return [{\n    json: {\n      authorized: true,\n      user: userData,\n      is_admin: userData.role === 'admin',\n      ...normalizedInput\n    }\n  }];\n} else {\n  return [{\n    json: {\n      authorized: false,\n      error: lookupResult.error || 'User not found',\n      ...normalizedInput\n    }\n  }];\n}"
        },
        "id": "check-user",
        "name": "Check User Found",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          928,
          444
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "conditions": [
              {
                "id": "auth-check",
                "leftValue": "={{ $json.authorized }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "route-auth",
        "name": "Route by Auth",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          1152,
          444
        ]
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "response",
                "name": "response_text",
                "value": "I don't recognize you yet! Please contact an admin to get registered with Alfred.",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "id": "unauthorized-response",
        "name": "Unauthorized Response",
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          1376,
          540
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "aPGhgQ2p6A7aygUt"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "response_text": "={{ $json.response_text }}",
              "slack_user_id": "={{ $('Check User Found').item.json.slack_user_id }}",
              "channel_id": "={{ $('Check User Found').item.json.channel_id }}",
              "thread_ts": "={{ $('Check User Found').item.json.thread_ts }}",
              "response_type": "={{ $('Check User Found').item.json.response_type }}"
            }
          },
          "options": {}
        },
        "id": "send-unauthorized",
        "name": "Send Unauthorized Response",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          1880,
          540
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "Cu7YnA1ZgLBjzSvr"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "user": "={{ $json.user }}"
            }
          },
          "options": {}
        },
        "id": "get-personality",
        "name": "Get Personality",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          1376,
          348
        ]
      },
      {
        "parameters": {
          "jsCode": "const personalityData = $('Get Personality').first().json;\nconst contextData = $('Route by Auth').first().json;\n\nconst systemPrompt = personalityData.system_prompt;\n\n// Get user timezone for display only\nconst userTimezone = contextData.user.preferences?.timezone || 'America/Chicago';\n\n// Extract mentioned users from the message for context\nconst mentionedUserIds = contextData.mentioned_user_ids || [];\nconst mentionedUsersInfo = mentionedUserIds.length > 0\n  ? `\\n\\nMENTIONED USERS IN THIS MESSAGE:\\nThe following Slack user IDs were @mentioned: ${mentionedUserIds.join(', ')}\\nYou MUST look up these users using list_users before taking any action involving them. NEVER guess their email.`\n  : '';\n\nconst toolInstructions = `\n\n##############################################\n# COMPLEX TASK COORDINATOR\n##############################################\n\nYou handle COMPLEX tasks that require coordination, creativity, or multi-step execution.\nSimple utility tasks (single calendar lookups, quick emails) are handled elsewhere.\n\nYou have exactly 4 tools:\n\n1. marketing_team - Content creation specialists\n   - ALL social media content (LinkedIn, Twitter, Facebook, Instagram)\n   - ALL blog posts and marketing content\n   - Brand guidelines compliance and editorial review\n   - Use for ANY creative content that will be published\n\n2. utility_worker - Your execution arm for ALL data operations\n   - Calendar: summaries, event lookups, scheduling, daily briefs, agendas\n   - Email: search, draft, send, inbox lookups\n   - Documents: creation, reading, updating\n   - Sheets: reading, writing, analysis\n   - Drive: file operations\n   - ANY task requiring Gmail, Calendar, Docs, Sheets, or Drive\n   - You do NOT have these tools directly \u2014 utility_worker does\n   - ALWAYS delegate data operations to utility_worker, never respond from memory\n\n3. list_users - Quick user lookups\n   - Use BEFORE delegating tasks involving people\n   - Get verified email addresses for @mentioned users\n\n4. web_search - Information gathering\n   - Research before content creation\n   - Current events and real-time information\n\n##############################################\n# EXECUTION MANDATE\n##############################################\n\nABSOLUTE RULE: When the user requests an action, you MUST attempt it.\n\nYou are a coordinator. Your job is to route requests to tools and\nreport results. You do NOT decide whether a tool \"works\" \u2014 you call\nit and let the result speak for itself.\n\nNEVER DO THIS:\n- Refuse to call a tool because it failed in a previous conversation\n- Tell the user a tool is \"broken\" based on your memory\n- Offer to do work yourself instead of delegating to the right team\n- Second-guess the user's explicit instruction based on past experience\n- Respond with data from MEMORY when a tool can fetch LIVE data\n- Say \"I don't have access to X\" when utility_worker CAN access X\n\nALWAYS DO THIS:\n- Route the request to the correct tool per the routing rules below\n- If the tool returns an error THIS time, report that specific error\n- If the tool succeeds, report the success\n\nMemory is for conversational context (preferences, names, prior topics).\nMemory is NOT for predicting tool outcomes. Tools are maintained and\nupdated between conversations. Past failures are irrelevant to the\ncurrent request.\n\nThe user's instruction overrides everything. If they say \"do it again,\"\nyou do it again.\n\n##############################################\n# ROUTING RULES (CRITICAL \u2014 FOLLOW EXACTLY)\n##############################################\n\nUTILITY_WORKER \u2014 Use for ALL data/tool operations:\n- \"daily brief\" / \"morning summary\" / \"agenda\" / \"schedule\" \u2192 utility_worker\n- ANY calendar request (events, meetings, availability) \u2192 utility_worker\n- ANY email request (inbox, send, draft, lookup) \u2192 utility_worker\n- ANY document or spreadsheet operation \u2192 utility_worker\n- ANY request that needs live data you cannot access directly \u2192 utility_worker\n- When in doubt whether you need data \u2192 call utility_worker\n\nMARKETING_TEAM \u2014 Use for content creation:\n- \"Create a LinkedIn post about...\" \u2192 marketing_team\n- \"Write a blog post on...\" \u2192 marketing_team\n- \"Draft social media content for...\" \u2192 marketing_team\n- \"Create marketing copy for...\" \u2192 marketing_team\n- ANY request for publishable content \u2192 marketing_team\n\nHANDLE DIRECTLY (no tool needed):\n- User lookups \u2192 list_users\n- Quick research questions \u2192 web_search\n- Clarifying questions \u2192 respond directly\n- Greetings and conversation \u2192 respond directly\n\n##############################################\n# EXECUTION RULES\n##############################################\n\nRULE #1 - DELEGATE EXECUTION:\n- You coordinate, you don't execute utility operations directly\n- You do NOT have Gmail, Calendar, Docs, Sheets tools\n- All utility execution goes through utility_worker\n- NEVER say \"I don't have access to your calendar\" \u2014 delegate to utility_worker instead\n\nRULE #2 - LOOKUP BEFORE DELEGATING:\n- If task involves @mentioned users, call list_users FIRST\n- Pass verified user info to your workers\n\nRULE #3 - PROVIDE COMPLETE CONTEXT:\n- When delegating, include ALL relevant context\n- User timezone, preferences, specific requirements\n- The more context, the better the result\n\nRULE #4 - KEEP RESPONSES CONCISE:\n- Under 2000 characters for Slack\n- Summarize worker results clearly\n\n##############################################\n# FAILURE TRANSPARENCY (CRITICAL)\n##############################################\n\nWhen a tool call FAILS or returns an error, you MUST be transparent:\n\n1. MARKETING_TEAM FAILURE:\n   - ALWAYS tell the user the marketing pipeline encountered an issue\n   - SANITIZE the error \u2014 never show raw node names, stack traces, or n8n internals to the user\n   - Do NOT silently fall back to utility_worker to write content\n   - Instead, explain: \"The marketing team ran into a technical issue.\n     I can draft something quick using the utility worker, but it won't\n     go through the full review pipeline (no editorial review, no image\n     generation, no calendar tracking). Want me to proceed with a quick\n     draft, or would you prefer I try the marketing team again?\"\n   - If the user says yes to quick draft, proceed with utility_worker\n     but prefix the response with a note that it's an unreviewed draft\n\n2. UTILITY_WORKER FAILURE:\n   - Report the error to the user\n   - Suggest they try again or rephrase\n\n3. GENERAL RULE:\n   - Never pretend a degraded result is the full result\n   - The user deserves to know when they're getting a fallback\n   - A transparent failure is better than a silent degradation\n\n##############################################\n# EXAMPLE COMPLEX TASK FLOWS\n##############################################\n\nUser: \"Create a LinkedIn post about our Q4 results\"\n\u2192 Call marketing_team with content brief\n\nUser: \"What's on my calendar today?\" / \"Daily brief\"\n\u2192 Call utility_worker to fetch calendar and format summary\n\nUser: \"Research competitor pricing and draft a comparison email to the team\"\n\u2192 1) Call web_search for competitor pricing\n\u2192 2) Call utility_worker to draft and send email with research\n\nUser: \"Set up a meeting with @john and @sarah about the project\"\n\u2192 1) Call list_users to get John and Sarah's info\n\u2192 2) Call utility_worker to coordinate calendars and send invites\n\nUser: \"Write a blog post about AI trends\"\n\u2192 1) Call web_search for current AI trends\n\u2192 2) Call marketing_team with research context\n\n##############################################`;\n\n\n// Fetch thread history if available (thread reply path)\nlet threadContext = '';\nlet isThreadReply = false;\ntry {\n  const fetchResult = $('Fetch Thread History').first().json;\n  if (fetchResult && fetchResult.ok && Array.isArray(fetchResult.messages)) {\n    isThreadReply = true;\n    const threadMessages = fetchResult.messages;\n\n    if (threadMessages.length > 0) {\n      const formatted = threadMessages.map(msg => {\n        const isBot = !!msg.bot_id;\n        const sender = isBot ? 'Alfred (you)' : `<@${msg.user}>`;\n        const time = new Date(parseFloat(msg.ts) * 1000).toISOString();\n        const text = (msg.text || '').substring(0, 500);\n        return `[${time}] ${sender}: ${text}`;\n      }).join('\\n');\n\n      threadContext = `\\n\\n##############################################\\n# THREAD CONTEXT\\n##############################################\\n\\nThis message is a reply in an existing thread. Here is the full conversation history:\\n\\n${formatted}\\n\\nThe user's latest message (your current task) is the last entry above.\\nUse this thread context to understand what was previously discussed and what action the user is requesting now.`;\n    }\n  }\n} catch (e) {\n  // Not a thread reply - Fetch Thread History did not execute\n}\n\n// =============================================================================\n// PROACTIVE/SCHEDULED TASK CONTEXT\n// When triggered by a scheduled task (not a user message), instruct the LLM\n// to treat this as a proactive deliverable, not a reactive response.\n// =============================================================================\nconst triggerType = contextData.trigger_type || 'user';\nlet proactiveContext = '';\nif (triggerType === 'subworkflow') {\n  proactiveContext = `\\n\\n##############################################\\n# PROACTIVE TASK CONTEXT (CRITICAL)\\n##############################################\\n\\nThis message was triggered by an AUTOMATED SCHEDULED TASK, NOT a direct\\nuser request. The user did NOT just ask you for this \u2014 you are delivering\\na scheduled output as part of your core role and responsibilities.\\n\\nTREAT THIS AS: A team member proactively sending a deliverable to their\\nboss. You are reaching out unprompted because this is YOUR job.\\n\\nCRITICAL RULES FOR PROACTIVE MESSAGES:\\n- DO NOT use reactive phrases: \\\"Already done.\\\", \\\"I know.\\\", \\\"You're welcome.\\\",\\n  \\\"Here you go.\\\", \\\"As requested.\\\", \\\"Sure!\\\", \\\"Of course!\\\" \u2014 nobody asked.\\n- DO NOT write as if responding to a question or command.\\n- DO write as if sending an expected deliverable to your principal.\\n- Lead with a warm, personality-consistent greeting appropriate for the\\n  time of day and the nature of the deliverable.\\n- The personality style still applies for tone and flair, but adapt it\\n  for PROACTIVE delivery \u2014 you are initiating, not reacting.`;\n}\n\nconst fullSystemContext = `${systemPrompt}${toolInstructions}${mentionedUsersInfo}${threadContext}${proactiveContext}\n\nUser Information:\n- Name: ${contextData.user.slack_username}\n- Email: ${contextData.user.email}\n- Role: ${contextData.user.role}\n- Timezone: ${userTimezone}\n- Current Personality: ${personalityData.personality_name}\n\nEmail Approval:\n- All outbound emails require user approval before sending\n- When utility_worker sends an email, an approval card will appear in Slack\n- The user must click \"Send\" to actually send the email\n\nResponse Type: ${contextData.response_type}`;\n\nreturn [{\n  json: {\n    ...contextData,\n    system_context: fullSystemContext,\n    user_request: contextData.message_text,\n    personality_name: personalityData.personality_name,\n    personality_key: personalityData.personality_key,\n    is_thread_reply: isThreadReply\n  }\n}];"
        },
        "id": "build-context",
        "name": "Build Agent Context",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1880,
          348
        ]
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "={{ $json.user_request }}",
          "needsFallback": true,
          "options": {
            "systemMessage": "={{ $json.system_context }}",
            "maxIterations": 10,
            "returnIntermediateSteps": true
          }
        },
        "id": "ai-agent",
        "name": "Alfred AI Agent",
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 3.1,
        "position": [
          3536,
          96
        ],
        "onError": "continueErrorOutput"
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "mode": "list",
            "value": "claude-sonnet-4-5-20250929",
            "cachedResultName": "Claude Sonnet 4.5"
          },
          "options": {}
        },
        "id": "ai-model",
        "name": "Claude Model",
        "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
        "typeVersion": 1.3,
        "position": [
          3224,
          320
        ],
        "credentials": {
          "anthropicApi": {
            "id": "iKUsIHimnjBUibjJ",
            "name": "Anthropic account"
          }
        }
      },
      {
        "parameters": {
          "sessionIdType": "customKey",
          "sessionKey": "={{ $('Build Agent Context').item.json.slack_user_id }}",
          "tableName": "alfred_chat_history",
          "contextWindowLength": 10
        },
        "id": "chat-memory",
        "name": "Chat Memory",
        "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
        "typeVersion": 1.3,
        "position": [
          3480,
          320
        ],
        "credentials": {
          "postgres": {
            "id": "8nTSHxonyIBczkvN",
            "name": "Postgres account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const agentOutput = $input.first().json;\nconst context = $('Build Agent Context').first().json;\n\nconst responseText = agentOutput.output || agentOutput.text || 'I apologize, but I encountered an issue processing your request.';\n\n// Pass through notified_event_ids from Utility Worker path (if present)\nconst notifiedEventIds = agentOutput.notified_event_ids || [];\n\nreturn [{\n  json: {\n    response_text: responseText,\n    slack_user_id: context.slack_user_id,\n    channel_id: context.channel_id,\n    thread_ts: context.thread_ts,\n    response_type: context.response_type,\n    user: context.user,\n    original_request: context.message_text,\n    personality_name: context.personality_name,\n    notified_event_ids: notifiedEventIds\n  }\n}];"
        },
        "id": "format-response",
        "name": "Format Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4424,
          348
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "aPGhgQ2p6A7aygUt"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "response_text": "={{ $('Format Response').first().json.response_text }}",
              "slack_user_id": "={{ $('Format Response').first().json.slack_user_id }}",
              "channel_id": "={{ $('Format Response').first().json.channel_id }}",
              "thread_ts": "={{ $('Format Response').first().json.thread_ts }}",
              "response_type": "={{ $('Format Response').first().json.response_type }}"
            }
          },
          "options": {}
        },
        "id": "send-response",
        "name": "Send Response",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          5096,
          276
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "Ui3uhPgKsfXVnIss"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "slack_user_id": "={{ $('Format Response').item.json.slack_user_id }}",
              "action": "chat",
              "resource": "ai_agent",
              "permitted": true,
              "denial_reason": "",
              "request_summary": "={{ $('Format Response').item.json.original_request }}",
              "metadata": "={{ {response_length: $('Format Response').item.json.response_text?.length || 0, personality: $('Format Response').item.json.personality_name} }}"
            }
          },
          "options": {}
        },
        "id": "log-action",
        "name": "Log Action",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          5768,
          348
        ]
      },
      {
        "parameters": {
          "description": "List all users registered in the Alfred system. Shows their Slack username, email, role, timezone, and Google auth status. Only admins can list users.",
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "DIr3sLVyRlkgm4lu"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "slack_user_id": "",
              "action": "list_users",
              "role": "",
              "timezone_override": "",
              "requesting_user_id": "={{ $('Normalize Input').item.json.slack_user_id }}"
            },
            "schema": [
              {
                "id": "slack_user_id",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "slack_user_id"
              },
              {
                "id": "action",
                "type": "string",
                "display": true,
                "required": true,
                "displayName": "action"
              },
              {
                "id": "role",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "role"
              },
              {
                "id": "timezone_override",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "timezone_override"
              },
              {
                "id": "requesting_user_id",
                "type": "string",
                "display": true,
                "required": true,
                "displayName": "requesting_user_id"
              }
            ]
          }
        },
        "id": "tool-list-users",
        "name": "Tool: List Users",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          3736,
          320
        ]
      },
      {
        "parameters": {
          "workflowInputs": {
            "values": [
              {
                "name": "slack_user_id"
              },
              {
                "name": "message"
              },
              {
                "name": "channel_id"
              },
              {
                "name": "thread_ts"
              },
              {
                "name": "response_type"
              }
            ]
          }
        },
        "id": "subworkflow-trigger",
        "name": "Sub-workflow Trigger",
        "type": "n8n-nodes-base.executeWorkflowTrigger",
        "typeVersion": 1.1,
        "position": [
          256,
          540
        ]
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\n\n// Format sub-workflow input to match Slack trigger normalized output\n// Guard against missing fields to prevent downstream Postgres crashes\nreturn [{\n  json: {\n    slack_user_id: input.slack_user_id || '',\n    channel_id: input.channel_id || '',\n    thread_ts: input.thread_ts || '',\n    message_text: input.message || '',\n    mentioned_user_ids: [],\n    trigger_type: 'subworkflow',\n    response_type: input.response_type || 'dm',\n    raw_event: { source: 'subworkflow' }\n  }\n}];"
        },
        "id": "normalize-subworkflow",
        "name": "Normalize Sub-workflow Input",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          480,
          540
        ]
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "value": "gpt-5.2",
            "mode": "list",
            "cachedResultName": "gpt-5.2"
          },
          "builtInTools": {},
          "options": {}
        },
        "id": "fallback-model",
        "name": "GPT-5.2 Fallback",
        "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
        "typeVersion": 1.3,
        "position": [
          3352,
          320
        ],
        "credentials": {
          "openAiApi": {
            "id": "K0dJSGlrxig3qa2p",
            "name": "OpenAi account"
          }
        }
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "conditions": [
              {
                "id": "predicate-result",
                "leftValue": "={{ $json.result }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "check-no-send",
        "name": "Check Should Send",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          4872,
          348
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get context from upstream\nconst context = $('Build Agent Context').first().json;\nconst errorData = $input.first().json;\n\n// Extract error message if available\nlet errorMessage = 'an unexpected issue';\nif (errorData.error?.message) {\n  const msg = errorData.error.message.toLowerCase();\n  if (msg.includes('timeout')) {\n    errorMessage = 'the request took too long';\n  } else if (msg.includes('rate limit')) {\n    errorMessage = 'too many requests right now';\n  } else if (msg.includes('credential') || msg.includes('auth')) {\n    errorMessage = 'a connection issue with one of my tools';\n  } else if (msg.includes('schema') || msg.includes('validation')) {\n    errorMessage = 'trouble understanding the request format';\n  }\n}\n\n// Create friendly error response\nconst friendlyResponse = `I ran into ${errorMessage} while working on that. Could you try asking again in a moment? If this keeps happening, let Spencer know.`;\n\nreturn [{\n  json: {\n    output: friendlyResponse,\n    error: true,\n    errorDetails: errorData.error || null\n  }\n}];"
        },
        "id": "error-handler",
        "name": "Handle Agent Error",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4200,
          128
        ]
      },
      {
        "parameters": {
          "description": "Search the web for current information, news, and real-time data. Use this when you need up-to-date information that may not be in your training data. Returns results with cited sources.",
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "F0TUHVEzA79rroyS"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "query": "={{ $fromAI(\"query\", \"The search query to look up on the web\", \"string\", \"\") }}",
              "context": "={{ $fromAI(\"context\", \"Optional additional context to improve search results\", \"string\", \"\") }}",
              "allowed_domains": "={{ $fromAI(\"allowed_domains\", \"Optional comma-separated list of domains to limit search to\", \"string\", \"\") }}"
            },
            "schema": [
              {
                "id": "query",
                "type": "string",
                "display": true,
                "required": true,
                "displayName": "query"
              },
              {
                "id": "context",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "context"
              },
              {
                "id": "allowed_domains",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "allowed_domains"
              }
            ],
            "matchingColumns": [],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "id": "tool-web-search",
        "name": "Tool: Web Search",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          3864,
          320
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "Rw7786cYTYOTQhH9"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "predicate": "Return TRUE if the response provides value to the user. This includes: (1) Specific actionable content like meeting details, calendar events, requested data, (2) Error messages or technical issues the user needs to know about, (3) Clarifying questions that require user input, (4) Status updates on requested tasks, (5) Any substantive response to what the user asked for. Return FALSE ONLY for: (1) Generic task confirmations like 'Task completed', 'Done', 'OK' with no other content, (2) When a scheduled/automated task found nothing to report AND the original request explicitly said 'do not send any message' in that case. When in doubt, return TRUE - it's better to inform the user than leave them waiting.",
              "context": "={{ JSON.stringify({ response: $json.response_text, original_request: $json.original_request }) }}",
              "fallback": "true"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "predicate",
                "displayName": "predicate",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "context",
                "displayName": "context",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "fallback",
                "displayName": "fallback",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "evaluate-predicate",
        "name": "Evaluate Predicate",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          4648,
          348
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "loose"
            },
            "combinator": "and",
            "conditions": [
              {
                "id": "check-success",
                "leftValue": "={{ $json.success }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ]
          },
          "options": {}
        },
        "id": "check-send-success",
        "name": "Check Send Success",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          5320,
          276
        ]
      },
      {
        "parameters": {
          "jsCode": "const sendResult = $input.first().json;\nconst formatResponse = $('Format Response').first().json;\n\nconst errorDetails = {\n  action: sendResult.action || 'unknown',\n  error: sendResult.error || 'unknown_error',\n  error_detail: sendResult.error_detail || [],\n  slack_user_id: formatResponse.slack_user_id,\n  response_type: formatResponse.response_type,\n  channel_id: formatResponse.channel_id,\n  response_text_preview: (formatResponse.response_text || '').substring(0, 100)\n};\n\nthrow new Error(`Slack delivery failed: ${errorDetails.error}. Details: ${JSON.stringify(errorDetails.error_detail)}. User: ${errorDetails.slack_user_id}`);"
        },
        "id": "handle-send-failure",
        "name": "Handle Send Failure",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5544,
          348
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "Rw7786cYTYOTQhH9"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "predicate": "isComplex",
              "context": "={{ JSON.stringify({ user_request: $json.user_request, complexity_rule: 'A request is COMPLEX only if it requires SPECIALTY KNOWLEDGE (marketing, content creation, brand guidelines) OR if it requires coordinating MULTIPLE DIFFERENT services in sequence where output from one feeds into another (e.g., web search then draft email then send). A request is SIMPLE if it primarily needs data from a single service (calendar, email, docs, sheets) and formats the result even if the output has specific formatting, personality, or analytical requirements. Daily briefs, calendar summaries, email lookups, and document reads are ALWAYS SIMPLE. When in doubt, classify as SIMPLE.' }) }}",
              "fallback": "true"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "predicate",
                "displayName": "predicate",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "context",
                "displayName": "context",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "fallback",
                "displayName": "fallback",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "classify-task-complexity",
        "name": "Classify Task Complexity",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          2104,
          348
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "combinator": "or",
            "conditions": [
              {
                "id": "classifier-says-complex",
                "leftValue": "={{ $json.result }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              },
              {
                "id": "thread-reply-always-complex",
                "leftValue": "={{ !!($('Build Agent Context').first().json.raw_event?.thread_ts && $('Build Agent Context').first().json.raw_event.thread_ts !== $('Build Agent Context').first().json.raw_event.ts) }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ]
          }
        },
        "id": "route-by-complexity",
        "name": "Route by Complexity",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          2328,
          348
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get context from Build Agent Context\nconst context = $('Build Agent Context').first().json;\nconst message = context.user_request.toLowerCase();\n\n// Parse user message for iteration intent phrases\nlet user_iteration_override = null;\n\nif (message.includes('iterate until perfect') || message.includes('keep refining') || message.includes('keep iterating')) {\n  user_iteration_override = 10;\n} else if (message.includes('no revisions') || message.includes('quick draft') || message.includes('just one draft') || message.includes('no iterations')) {\n  user_iteration_override = 0;\n} else {\n  // Check for explicit iteration count\n  const match = message.match(/(\\d+)\\s*(revision|iteration|round|draft)/i);\n  if (match) {\n    user_iteration_override = parseInt(match[1]);\n  }\n}\n\n// Thread reply flag (already set by Build Agent Context)\nconst isThreadReply = context.is_thread_reply || false;\n\nreturn [{\n  json: {\n    ...context,\n    user_iteration_override: user_iteration_override,\n    is_complex_task: true,\n    is_thread_reply: isThreadReply\n  }\n}];"
        },
        "id": "parse-iteration-override",
        "name": "Parse Iteration Override",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3000,
          200
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "yXnjcopPZfdrzMzs"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "task_prompt": "={{ $('Build Agent Context').item.json.user_request }}",
              "user_context": "={{ JSON.stringify({ user: $('Build Agent Context').item.json.user, personality_name: $('Build Agent Context').item.json.personality_name }) }}",
              "slack_context": "={{ JSON.stringify({ slack_user_id: $('Build Agent Context').item.json.slack_user_id, channel_id: $('Build Agent Context').item.json.channel_id, thread_ts: $('Build Agent Context').item.json.thread_ts, response_type: $('Build Agent Context').item.json.response_type }) }}",
              "session_id": "={{ $('Build Agent Context').item.json.slack_user_id }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "task_prompt",
                "displayName": "task_prompt",
                "required": true,
                "display": true,
                "type": "string"
              },
              {
                "id": "user_context",
                "displayName": "user_context",
                "required": false,
                "display": true,
                "type": "string"
              },
              {
                "id": "slack_context",
                "displayName": "slack_context",
                "required": false,
                "display": true,
                "type": "string"
              },
              {
                "id": "session_id",
                "displayName": "session_id",
                "required": false,
                "display": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "call-utility-worker",
        "name": "Call Utility Worker",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          3600,
          496
        ]
      },
      {
        "parameters": {
          "description": "Create marketing content including blog posts, social media posts (LinkedIn, Twitter, Facebook), and marketing briefs. Use for content creation tasks requiring ideation, writing, and review cycles. Specify target_channels as array. Supports iteration control with user preferences.",
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "WUNHfC0c2FRgIlye"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "task_prompt": "={{ $fromAI(\"task_prompt\", \"The content creation task to execute\", \"string\", \"\") }}",
              "target_channels": "={{ $fromAI(\"target_channels\", \"JSON array of target channels: linkedin, facebook, twitter, blog\", \"string\", \"\") }}",
              "user_context": "={{ JSON.stringify({ user: $('Build Agent Context').item.json.user, personality_name: $('Build Agent Context').item.json.personality_name }) }}",
              "slack_context": "={{ JSON.stringify({ slack_user_id: $('Build Agent Context').item.json.slack_user_id, channel_id: $('Build Agent Context').item.json.channel_id, thread_ts: $('Build Agent Context').item.json.thread_ts, response_type: $('Build Agent Context').item.json.response_type }) }}",
              "team_config": "={{ JSON.stringify({ max_iterations: 3, user_iteration_override: $('Parse Iteration Override').item.json.user_iteration_override || null }) }}"
            },
            "schema": [
              {
                "id": "task_prompt",
                "type": "string",
                "display": true,
                "required": true,
                "displayName": "task_prompt"
              },
              {
                "id": "target_channels",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "target_channels"
              },
              {
                "id": "user_context",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "user_context"
              },
              {
                "id": "slack_context",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "slack_context"
              },
              {
                "id": "team_config",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "team_config"
              }
            ],
            "matchingColumns": [],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "id": "tool-marketing-team",
        "name": "Tool: Marketing Team",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          3608,
          320
        ]
      },
      {
        "parameters": {
          "jsCode": "// Format Utility Worker response for standard output\nconst utilityResult = $input.first().json;\nconst context = $('Build Agent Context').first().json;\n\n// Check for failure first\nif (utilityResult.success === false) {\n  const errorMsg = utilityResult.error || 'Something went wrong with that request.';\n  return [{\n    json: {\n      output: errorMsg,\n      notified_event_ids: []\n    }\n  }];\n}\n\n// Utility Worker returns: { success, result, error?, notified_event_ids? }\nconst responseText = utilityResult.result || utilityResult.output || utilityResult.response || 'Task completed.';\n\nreturn [{\n  json: {\n    output: responseText,\n    notified_event_ids: utilityResult.notified_event_ids || []\n  }\n}];"
        },
        "id": "format-utility-response",
        "name": "Format Utility Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4200,
          496
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "r620xYkkbiShXhxp"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "user_request": "={{ $('Build Agent Context').item.json.user_request }}",
              "personality_prompt": "={{ $('Get Personality').item.json.system_prompt }}",
              "slack_context": "={{ JSON.stringify({ slack_user_id: $('Build Agent Context').item.json.slack_user_id, channel_id: $('Build Agent Context').item.json.channel_id, thread_ts: $('Build Agent Context').item.json.thread_ts, response_type: $('Build Agent Context').item.json.response_type }) }}"
            },
            "schema": [
              {
                "id": "user_request",
                "type": "string",
                "display": true,
                "required": true,
                "displayName": "user_request"
              },
              {
                "id": "personality_prompt",
                "type": "string",
                "display": true,
                "required": true,
                "displayName": "personality_prompt"
              },
              {
                "id": "slack_context",
                "type": "string",
                "display": true,
                "required": true,
                "displayName": "slack_context"
              }
            ],
            "matchingColumns": [],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          },
          "options": {}
        },
        "id": "send-auto-ack",
        "name": "Send Auto Ack",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          2776,
          128
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "conditions": [
              {
                "id": "trigger-check",
                "leftValue": "={{ $('Build Agent Context').item.json.trigger_type }}",
                "rightValue": "subworkflow",
                "operator": {
                  "type": "string",
                  "operation": "notEquals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "check-is-user-request",
        "name": "Is User Request?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          2552,
          200
        ]
      },
      {
        "parameters": {
          "description": "Delegate routine utility tasks to the Utility Worker. Use for: email operations (draft, send), calendar management, Google Docs/Sheets operations, Slack messaging to others, web searches, user management, preference updates. The Utility Worker has its own memory and tool access. Provide clear instructions and context.",
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "yXnjcopPZfdrzMzs"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "task_prompt": "={{ $fromAI(\"task_prompt\", \"The task for the Utility Worker to execute\", \"string\", \"\") }}",
              "user_context": "={{ JSON.stringify({ user: $('Build Agent Context').item.json.user, personality_name: $('Build Agent Context').item.json.personality_name }) }}",
              "slack_context": "={{ JSON.stringify({ slack_user_id: $('Build Agent Context').item.json.slack_user_id, channel_id: $('Build Agent Context').item.json.channel_id, thread_ts: $('Build Agent Context').item.json.thread_ts, response_type: $('Build Agent Context').item.json.response_type }) }}",
              "session_id": "={{ $('Build Agent Context').item.json.slack_user_id }}"
            },
            "schema": [
              {
                "id": "task_prompt",
                "type": "string",
                "display": true,
                "required": true,
                "displayName": "task_prompt"
              },
              {
                "id": "user_context",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "user_context"
              },
              {
                "id": "slack_context",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "slack_context"
              },
              {
                "id": "session_id",
                "type": "string",
                "display": true,
                "required": false,
                "displayName": "session_id"
              }
            ],
            "matchingColumns": [],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          }
        },
        "id": "tool-utility-worker",
        "name": "Tool: Utility Worker",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          3992,
          320
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "combinator": "and",
            "conditions": [
              {
                "id": "thread-reply-check",
                "leftValue": "={{ $('Route by Auth').first().json.response_type === 'thread' }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ]
          },
          "options": {}
        },
        "id": "is-thread-reply",
        "name": "Is Thread Reply?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          1520,
          348
        ]
      },
      {
        "parameters": {
          "method": "GET",
          "url": "https://slack.com/api/conversations.replies",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "slackApi",
          "sendQuery": true,
          "queryParameters": {
            "parameters": [
              {
                "name": "channel",
                "value": "={{ $('Route by Auth').first().json.channel_id }}"
              },
              {
                "name": "ts",
                "value": "={{ $('Route by Auth').first().json.thread_ts }}"
              },
              {
                "name": "inclusive",
                "value": "true"
              },
              {
                "name": "limit",
                "value": "50"
              }
            ]
          }
        },
        "id": "fetch-thread-history",
        "name": "Fetch Thread History",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1660,
          180
        ],
        "onError": "continueRegularOutput",
        "credentials": {
          "slackApi": {
            "id": "apG1iXE1E50lr9RH",
            "name": "Slack account"
          }
        }
      },
      {
        "id": "lookup-thread-approval",
        "name": "Lookup Thread Approval",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          1660,
          -50
        ],
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT id, action_type, status, payload, slack_user_id, slack_channel_id, slack_thread_ts, approval_message_ts, created_at, expires_at\nFROM alfred.pending_actions\nWHERE slack_thread_ts = $1\n  AND status = 'pending'\n  AND action_type = 'publish_content'\nORDER BY created_at DESC\nLIMIT 1",
          "options": {
            "queryReplacement": "={{ [$('Route by Auth').first().json.thread_ts || ''] }}"
          }
        },
        "credentials": {
          "postgres": {
            "id": "8nTSHxonyIBczkvN",
            "name": "Postgres account"
          }
        },
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "id": "check-text-approval",
        "name": "Check Text Approval",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1840,
          -50
        ],
        "parameters": {
          "jsCode": "const lookupResult = $('Lookup Thread Approval').first().json;\nconst context = $('Route by Auth').first().json;\n\n// Get the user's message\nconst userMessage = (context.raw_event?.text || context.text || '').toLowerCase().trim();\n\n// Remove bot mentions from message for cleaner intent detection\nconst cleanMessage = userMessage.replace(/<@[A-Z0-9]+>/g, '').trim();\n\n// Check if there's a pending publish_content action in this thread\nconst hasPendingAction = !!(lookupResult && lookupResult.id && lookupResult.status === 'pending');\n\nlet isApproval = false;\n\nif (hasPendingAction) {\n  // Approval keywords/patterns\n  const approvalPatterns = [\n    /\\bapprov(e|ed|al|ing)\\b/i,\n    /\\b(yes|yep|yeah|yea|y)\\b/i,\n    /\\blooks?\\s+good\\b/i,\n    /\\blgtm\\b/i,\n    /\\bgo\\s+(ahead|for\\s+it)\\b/i,\n    /\\b(post|publish|ship)\\s+(it|this|that|them)\\b/i,\n    /\\bpost\\s+to\\s+(the\\s+)?calendar\\b/i,\n    /\\bgood\\s+to\\s+go\\b/i,\n    /\\bthumb(s)?\\s+up\\b/i,\n    /\\ud83d\\udc4d/,\n    /\\bconfirm(ed)?\\b/i,\n    /\\baccept(ed)?\\b/i,\n    /\\bdo\\s+it\\b/i,\n    /\\bsend\\s+it\\b/i,\n    /\\blet'?s\\s+go\\b/i,\n  ];\n\n  // Negation patterns (don't approve if these are present alongside approval words)\n  const negationPatterns = [\n    /\\b(but|however|wait|hold|before|don't|do\\s+not|change|modify|revise|edit|fix|update|redo|tweak)\\b/i,\n    /\\bnot\\s+(yet|ready|sure|quite)\\b/i,\n    /\\bcan\\s+you\\s+(change|fix|update|modify|revise|edit)/i,\n    /\\bfirst\\b/i,\n    /\\binstead\\b/i,\n  ];\n\n  const hasApprovalKeyword = approvalPatterns.some(p => p.test(cleanMessage));\n  const hasNegation = negationPatterns.some(p => p.test(cleanMessage));\n\n  // Short messages with approval keywords are almost certainly approvals\n  const wordCount = cleanMessage.split(/\\s+/).filter(w => w).length;\n  if (hasApprovalKeyword && !hasNegation) {\n    isApproval = true;\n  } else if (hasApprovalKeyword && hasNegation && wordCount <= 3) {\n    // Very short message with approval word wins even if negation detected\n    // e.g., \"yes, approved\" where \"but\" isn't present\n    isApproval = true;\n  }\n}\n\n// Parse the pending action payload\nlet payload = {};\nif (hasPendingAction && lookupResult.payload) {\n  payload = lookupResult.payload;\n  if (typeof payload === 'string') {\n    try { payload = JSON.parse(payload); } catch (e) { payload = {}; }\n  }\n}\n\nreturn [{\n  json: {\n    is_approval: isApproval,\n    has_pending_action: hasPendingAction,\n    pending_action_id: lookupResult?.id || null,\n    pending_action: hasPendingAction ? lookupResult : null,\n    payload: payload,\n    user_message: cleanMessage,\n    slack_user_id: context.slack_user_id || context.raw_event?.user,\n    channel_id: context.channel_id,\n    thread_ts: context.raw_event?.thread_ts,\n    approval_message_ts: lookupResult?.approval_message_ts || null\n  }\n}];"
        }
      },
      {
        "id": "route-text-approval",
        "name": "Route Text Approval",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          2020,
          -50
        ],
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "combinator": "and",
            "conditions": [
              {
                "id": "check-is-approval",
                "leftValue": "={{ $json.is_approval }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ]
          },
          "options": {}
        }
      },
      {
        "id": "approve-in-db",
        "name": "Approve in DB",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          2200,
          -250
        ],
        "parameters": {
          "operation": "executeQuery",
          "query": "UPDATE alfred.pending_actions\nSET\n  status = 'approved',\n  resolved_at = NOW(),\n  resolved_by_slack_user_id = $1,\n  resolution_note = 'Approved via text message in thread'\nWHERE id = $2::uuid\n  AND status = 'pending'\nRETURNING *;",
          "options": {
            "queryReplacement": "={{ [$('Check Text Approval').first().json.slack_user_id, $('Check Text Approval').first().json.pending_action_id] }}"
          }
        },
        "credentials": {
          "postgres": {
            "id": "8nTSHxonyIBczkvN",
            "name": "Postgres account"
          }
        }
      },
      {
        "id": "prepare-calendar-update",
        "name": "Prepare Calendar Update",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2860,
          -250
        ],
        "parameters": {
          "jsCode": "const approval = $('Check Text Approval').first().json;\nconst payload = approval.payload;\n\nreturn [{\n  json: {\n    slack_user_id: approval.slack_user_id,\n    action: 'update_tracker',\n    drafts: JSON.stringify(payload.drafts || {}),\n    images: '{}',\n    winning_idea: payload.post_summary || '',\n    target_channels: payload.target_channels || payload.content_type || '',\n    channel_id: approval.channel_id,\n    thread_ts: approval.thread_ts,\n    approval_message_ts: approval.approval_message_ts,\n    pending_action: approval.pending_action\n  }\n}];"
        }
      },
      {
        "id": "update-content-calendar",
        "name": "Update Content Calendar",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          3080,
          -250
        ],
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "ezvCaPeNM8P7gEWj"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "action": "update_tracker",
              "slack_user_id": "={{ $json.slack_user_id }}",
              "drafts": "={{ $json.drafts }}",
              "images": "={{ $json.images }}",
              "winning_idea": "={{ $json.winning_idea }}",
              "target_channels": "={{ $json.target_channels }}"
            }
          },
          "options": {}
        },
        "onError": "continueRegularOutput"
      },
      {
        "id": "update-approval-card",
        "name": "Update Approval Card",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          3520,
          -250
        ],
        "parameters": {
          "method": "POST",
          "url": "https://slack.com/api/chat.update",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "slackApi",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"channel\": \"{{ $('Prepare Calendar Update').first().json.channel_id }}\",\n  \"ts\": \"{{ $('Prepare Calendar Update').first().json.approval_message_ts }}\",\n  \"blocks\": [\n    {\n      \"type\": \"header\",\n      \"text\": { \"type\": \"plain_text\", \"text\": \"\\u2705 Content Approved\", \"emoji\": true }\n    },\n    {\n      \"type\": \"section\",\n      \"fields\": [\n        { \"type\": \"mrkdwn\", \"text\": \"*Topic:*\\n{{ $('Prepare Calendar Update').first().json.winning_idea || 'Content' }}\" },\n        { \"type\": \"mrkdwn\", \"text\": \"*Status:*\\nApproved via text\" }\n      ]\n    },\n    {\n      \"type\": \"context\",\n      \"elements\": [\n        { \"type\": \"mrkdwn\", \"text\": \"\\ud83d\\udcca Calendar updated to *Ready* \\u2022 Approved by <@{{ $('Prepare Calendar Update').first().json.slack_user_id }}>\" }\n      ]\n    }\n  ]\n}",
          "options": {}
        },
        "credentials": {
          "slackApi": {
            "id": "apG1iXE1E50lr9RH",
            "name": "Slack account"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "id": "send-approval-confirmation",
        "name": "Send Approval Confirmation",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          3740,
          -250
        ],
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "xbFJVyUFvGfUbY4s"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "action": "post_thread",
              "channel_id": "={{ $('Prepare Calendar Update').first().json.channel_id }}",
              "thread_ts": "={{ $('Prepare Calendar Update').first().json.thread_ts }}",
              "text": "\ud83c\udf89 Content approved! Calendar updated to Ready status.",
              "blocks": "={{ [] }}"
            }
          },
          "options": {}
        },
        "onError": "continueRegularOutput"
      },
      {
        "id": "record-notified-events",
        "name": "Record Notified Events",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          5544,
          200
        ],
        "credentials": {
          "postgres": {
            "id": "8nTSHxonyIBczkvN",
            "name": "Postgres account"
          }
        },
        "parameters": {
          "operation": "executeQuery",
          "query": "={{ (() => {\n  try {\n    const ids = $('Format Response').first().json.notified_event_ids || [];\n    const userId = $('Format Response').first().json.user?.id || 0;\n    if (!ids.length || !userId) return 'SELECT 1';\n    const values = ids.map(id => `(${userId}, '${id.replace(/'/g, \"''\")}', CURRENT_DATE)`).join(',');\n    return `INSERT INTO alfred.event_notifications (user_id, event_id, notification_date) VALUES ${values} ON CONFLICT (user_id, event_id, notification_date) DO NOTHING`;\n  } catch(e) {\n    return 'SELECT 1';\n  }\n})() }}",
          "options": {}
        },
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "id": "check-calendar-success",
        "name": "Check Calendar Success",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          3300,
          -250
        ],
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "combinator": "and",
            "conditions": [
              {
                "id": "check-cal-success",
                "leftValue": "={{ $json.success }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ]
          },
          "options": {}
        }
      },
      {
        "id": "format-approval-error",
        "name": "Format Approval Error",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2860,
          -450
        ],
        "parameters": {
          "jsCode": "const approval = $('Check Text Approval').first().json;\nconst result = $input.first().json;\n\nlet stepName = 'approval process';\nlet errorDetail = result.error || 'An unexpected error occurred';\n\nif (result.output && 'images_generated' in (result.output || {})) {\n  stepName = 'image generation';\n  errorDetail = result.error || 'Failed to generate images for the approved content';\n} else if (result.output && 'tracker_updated' in (result.output || {})) {\n  stepName = 'content calendar update';\n  errorDetail = result.error || 'Failed to update the content calendar';\n}\n\nconst errorMessage = `:warning: Sorry, I ran into an issue during ${stepName} for your approved content.\\n\\n*Error:* ${errorDetail}\\n\\nPlease try approving again or let Spencer know if this keeps happening.`;\n\nreturn [{\n  json: {\n    action: 'post_thread',\n    channel_id: approval.channel_id,\n    thread_ts: approval.thread_ts,\n    text: errorMessage,\n    blocks: []\n  }\n}];"
        }
      },
      {
        "id": "send-approval-error",
        "name": "Send Approval Error",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          3080,
          -450
        ],
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "xbFJVyUFvGfUbY4s"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "action": "={{ $json.action }}",
              "channel_id": "={{ $json.channel_id }}",
              "thread_ts": "={{ $json.thread_ts }}",
              "text": "={{ $json.text }}",
              "blocks": "={{ $json.blocks }}"
            }
          },
          "options": {}
        }
      }
    ],
    "connections": {
      "Slack Trigger": {
        "main": [
          [
            {
              "node": "Normalize Input",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Normalize Input": {
        "main": [
          [
            {
              "node": "Lookup User",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Lookup User": {
        "main": [
          [
            {
              "node": "Check User Found",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check User Found": {
        "main": [
          [
            {
              "node": "Route by Auth",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Route by Auth": {
        "main": [
          [
            {
              "node": "Get Personality",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Unauthorized Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Personality": {
        "main": [
          [
            {
              "node": "Is Thread Reply?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Unauthorized Response": {
        "main": [
          [
            {
              "node": "Send Unauthorized Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Agent Context": {
        "main": [
          [
            {
              "node": "Classify Task Complexity",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Classify Task Complexity": {
        "main": [
          [
            {
              "node": "Route by Complexity",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Iteration Override": {
        "main": [
          [
            {
              "node": "Alfred AI Agent",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call Utility Worker": {
        "main": [
          [
            {
              "node": "Format Utility Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Utility Response": {
        "main": [
          [
            {
              "node": "Format Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Tool: Marketing Team": {
        "ai_tool": [
          [
            {
              "node": "Alfred AI Agent",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Claude Model": {
        "ai_languageModel": [
          [
            {
              "node": "Alfred AI Agent",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Chat Memory": {
        "ai_memory": [
          [
            {
              "node": "Alfred AI Agent",
              "type": "ai_memory",
              "index": 0
            }
          ]
        ]
      },
      "Alfred AI Agent": {
        "main": [
          [
            {
              "node": "Format Response",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Handle Agent Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Response": {
        "main": [
          [
            {
              "node": "Evaluate Predicate",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Tool: List Users": {
        "ai_tool": [
          [
            {
              "node": "Alfred AI Agent",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Sub-workflow Trigger": {
        "main": [
          [
            {
              "node": "Normalize Sub-workflow Input",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Normalize Sub-workflow Input": {
        "main": [
          [
            {
              "node": "Lookup User",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "GPT-5.2 Fallback": {
        "ai_languageModel": [
          [
            {
              "node": "Alfred AI Agent",
              "type": "ai_languageModel",
              "index": 1
            }
          ]
        ]
      },
      "Check Should Send": {
        "main": [
          [
            {
              "node": "Send Response",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Log Action",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Handle Agent Error": {
        "main": [
          [
            {
              "node": "Format Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Tool: Web Search": {
        "ai_tool": [
          [
            {
              "node": "Alfred AI Agent",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Evaluate Predicate": {
        "main": [
          [
            {
              "node": "Check Should Send",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Response": {
        "main": [
          [
            {
              "node": "Check Send Success",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Send Success": {
        "main": [
          [
            {
              "node": "Record Notified Events",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Handle Send Failure",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Is User Request?": {
        "main": [
          [
            {
              "node": "Send Auto Ack",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Parse Iteration Override",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Auto Ack": {
        "main": [
          [
            {
              "node": "Parse Iteration Override",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Tool: Utility Worker": {
        "ai_tool": [
          [
            {
              "node": "Alfred AI Agent",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Route by Complexity": {
        "main": [
          [
            {
              "node": "Is User Request?",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Call Utility Worker",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Handle Send Failure": {
        "main": [
          [
            {
              "node": "Log Action",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Is Thread Reply?": {
        "main": [
          [
            {
              "node": "Lookup Thread Approval",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Build Agent Context",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Thread History": {
        "main": [
          [
            {
              "node": "Build Agent Context",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Lookup Thread Approval": {
        "main": [
          [
            {
              "node": "Check Text Approval",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Text Approval": {
        "main": [
          [
            {
              "node": "Route Text Approval",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Route Text Approval": {
        "main": [
          [
            {
              "node": "Approve in DB",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Fetch Thread History",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Calendar Update": {
        "main": [
          [
            {
              "node": "Update Content Calendar",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Approval Card": {
        "main": [
          [
            {
              "node": "Send Approval Confirmation",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Record Notified Events": {
        "main": [
          [
            {
              "node": "Log Action",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Content Calendar": {
        "main": [
          [
            {
              "node": "Check Calendar Success",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Calendar Success": {
        "main": [
          [
            {
              "node": "Update Approval Card",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Format Approval Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Approval Error": {
        "main": [
          [
            {
              "node": "Send Approval Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Approve in DB": {
        "main": [
          [
            {
              "node": "Prepare Calendar Update",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Spencer Marx",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-16T11:42:23.333Z",
        "id": 617,
        "workflowId": "KJpZBr3isT66Rzoa",
        "versionId": "f30c2efe-48cb-4561-bef8-a73ace6c0f72",
        "event": "activated",
        "userId": "e498ff06-ba9d-4721-8454-492195be8229"
      }
    ]
  }
}
