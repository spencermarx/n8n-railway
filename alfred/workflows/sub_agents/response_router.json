{
  "updatedAt": "2026-02-04T15:19:48.569Z",
  "createdAt": "2026-02-03T10:37:20.548Z",
  "id": "aPGhgQ2p6A7aygUt",
  "name": "ðŸ“¤ Sub-Agent | Response Router",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "id": "trigger",
      "name": "Workflow Input",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [250, 300],
      "parameters": {
        "workflowInputs": {
          "values": [
            {"name": "response_text", "type": "string"},
            {"name": "slack_user_id", "type": "string"},
            {"name": "channel_id", "type": "string"},
            {"name": "thread_ts", "type": "string"},
            {"name": "response_type", "type": "string"}
          ]
        }
      }
    },
    {
      "id": "build-blocks",
      "name": "Build Block Kit Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [580, 300],
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst formatterResult = input;\nconst originalInput = $('Workflow Input').first().json;\n\nconst text = formatterResult.formatted || originalInput.response_text || '';\n\nconst MAX_TEXT_LENGTH = 2900;\nconst MAX_BLOCKS = 45;\nconst MAX_TOTAL_CHARS = 15000;\n\nfunction textSection(text) {\n  return { type: 'section', text: { type: 'mrkdwn', text: text.substring(0, MAX_TEXT_LENGTH) } };\n}\n\nfunction headerBlock(text) {\n  return { type: 'header', text: { type: 'plain_text', text: text.substring(0, 150), emoji: true } };\n}\n\nfunction divider() {\n  return { type: 'divider' };\n}\n\nfunction contextBlock(elements) {\n  return { type: 'context', elements: elements.map(el => ({ type: 'mrkdwn', text: el.substring(0, 300) })) };\n}\n\nfunction splitIntoChunks(text, maxLength) {\n  const chunks = [];\n  let remaining = text;\n  \n  while (remaining.length > 0) {\n    if (remaining.length <= maxLength) {\n      chunks.push(remaining);\n      break;\n    }\n    \n    let breakPoint = maxLength;\n    const newlineIdx = remaining.lastIndexOf('\\n', maxLength);\n    const periodIdx = remaining.lastIndexOf('. ', maxLength);\n    const spaceIdx = remaining.lastIndexOf(' ', maxLength);\n    \n    if (newlineIdx > maxLength * 0.5) breakPoint = newlineIdx + 1;\n    else if (periodIdx > maxLength * 0.5) breakPoint = periodIdx + 2;\n    else if (spaceIdx > maxLength * 0.5) breakPoint = spaceIdx + 1;\n    \n    chunks.push(remaining.substring(0, breakPoint));\n    remaining = remaining.substring(breakPoint);\n  }\n  \n  return chunks;\n}\n\nfunction parseToBlocks(text) {\n  const blocks = [];\n  const lines = text.split('\\n');\n  let currentSection = [];\n  let inCodeBlock = false;\n  let codeContent = [];\n  let totalChars = 0;\n  \n  function addBlock(block) {\n    if (blocks.length >= MAX_BLOCKS) return false;\n    const blockText = JSON.stringify(block);\n    if (totalChars + blockText.length > MAX_TOTAL_CHARS) return false;\n    blocks.push(block);\n    totalChars += blockText.length;\n    return true;\n  }\n  \n  function flushSection() {\n    if (currentSection.length > 0) {\n      const content = currentSection.join('\\n').trim();\n      if (content) {\n        const chunks = splitIntoChunks(content, MAX_TEXT_LENGTH);\n        for (const chunk of chunks) {\n          if (!addBlock(textSection(chunk))) return false;\n        }\n      }\n      currentSection = [];\n    }\n    return true;\n  }\n  \n  function flushCode() {\n    if (codeContent.length > 0) {\n      const code = codeContent.join('\\n');\n      addBlock(textSection('```' + code.substring(0, MAX_TEXT_LENGTH - 10) + '```'));\n      codeContent = [];\n    }\n  }\n  \n  for (let i = 0; i < lines.length && blocks.length < MAX_BLOCKS; i++) {\n    const line = lines[i];\n    \n    if (line.trim().startsWith('```')) {\n      if (inCodeBlock) { flushCode(); inCodeBlock = false; }\n      else { if (!flushSection()) break; inCodeBlock = true; }\n      continue;\n    }\n    \n    if (inCodeBlock) { codeContent.push(line); continue; }\n    \n    const headerMatch = line.match(/^#{1,3}\\s+(.+)$/);\n    if (headerMatch) { \n      if (!flushSection()) break;\n      addBlock(headerBlock(headerMatch[1].replace(/\\*+/g, '').trim())); \n      continue; \n    }\n    \n    const boldHeaderMatch = line.match(/^\\*{1,2}([^*]+):\\*{1,2}\\s*$/);\n    if (boldHeaderMatch) { \n      if (!flushSection()) break;\n      addBlock(headerBlock(boldHeaderMatch[1].trim())); \n      continue; \n    }\n    \n    if (line.match(/^[\\-=_]{3,}$/)) {\n      const dividerCount = blocks.filter(b => b.type === 'divider').length;\n      if (dividerCount < 5) {\n        if (!flushSection()) break;\n        addBlock(divider());\n      }\n      continue;\n    }\n    \n    if (line.trim() === '') {\n      if (currentSection.length > 0) currentSection.push('');\n      continue;\n    }\n    \n    const listMatch = line.match(/^\\s*[\\-\\*â€¢]\\s+(.+)$/);\n    if (listMatch) { currentSection.push('â€¢ ' + listMatch[1]); continue; }\n    \n    const numberedMatch = line.match(/^\\s*(\\d+)[.)\\-]\\s+(.+)$/);\n    if (numberedMatch) { currentSection.push(numberedMatch[1] + '. ' + numberedMatch[2]); continue; }\n    \n    currentSection.push(line);\n  }\n  \n  if (inCodeBlock) flushCode();\n  flushSection();\n  \n  return blocks;\n}\n\nlet blocks = parseToBlocks(text);\nlet wasTruncated = false;\n\nif (blocks.length >= MAX_BLOCKS || text.length > MAX_TOTAL_CHARS) {\n  wasTruncated = true;\n  blocks.push(contextBlock(['_Content condensed for Slack. Full response available in workflow execution._']));\n}\n\nif (blocks.length === 0) {\n  blocks = [textSection(text.substring(0, MAX_TEXT_LENGTH) || 'I processed your request.')];\n}\n\nlet isValid = true;\nfor (let i = 0; i < blocks.length; i++) {\n  const block = blocks[i];\n  if (!block.type) { isValid = false; break; }\n  if (block.type === 'section' && (!block.text || !block.text.text)) { isValid = false; break; }\n  if (block.type === 'header' && (!block.text || !block.text.text)) { isValid = false; break; }\n}\n\nconst fallbackText = text.substring(0, 4000) + (text.length > 4000 ? '...' : '');\n\nreturn [{\n  json: {\n    ...originalInput,\n    blocks: isValid ? blocks : [textSection(fallbackText.substring(0, MAX_TEXT_LENGTH))],\n    fallback_text: fallbackText,\n    is_valid: isValid,\n    block_count: blocks.length,\n    was_truncated: wasTruncated,\n    original_length: text.length\n  }\n}];"
      }
    },
    {
      "id": "route-response",
      "name": "Route by Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [690, 300],
      "parameters": {
        "mode": "rules",
        "rules": {
          "values": [
            {
              "outputKey": "dm",
              "conditions": {
                "options": {"version": 2, "leftValue": "", "caseSensitive": true, "typeValidation": "strict"},
                "conditions": [{"leftValue": "={{ $json.response_type }}", "rightValue": "dm", "operator": {"type": "string", "operation": "equals"}}],
                "combinator": "and"
              }
            },
            {
              "outputKey": "channel",
              "conditions": {
                "options": {"version": 2, "leftValue": "", "caseSensitive": true, "typeValidation": "strict"},
                "conditions": [{"leftValue": "={{ $json.response_type }}", "rightValue": "channel", "operator": {"type": "string", "operation": "equals"}}],
                "combinator": "and"
              }
            },
            {
              "outputKey": "thread",
              "conditions": {
                "options": {"version": 2, "leftValue": "", "caseSensitive": true, "typeValidation": "strict"},
                "conditions": [{"leftValue": "={{ $json.response_type }}", "rightValue": "thread", "operator": {"type": "string", "operation": "equals"}}],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {"fallbackOutput": "extra"}
      }
    },
    {
      "id": "format-for-slack",
      "name": "Format for Slack",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [360, 300],
      "parameters": {
        "workflowId": {"__rl": true, "mode": "id", "value": "p8NeRHTMtdAqbPBk"},
        "workflowInputs": {"mappingMode": "defineBelow", "value": {"text": "={{ $json.response_text }}"}},
        "options": {}
      }
    },
    {
      "id": "call-slack-dm",
      "name": "Send DM",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [940, 60],
      "parameters": {
        "workflowId": {"__rl": true, "mode": "id", "value": "xbFJVyUFvGfUbY4s"},
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "action": "post_message",
            "user_id": "={{ $json.slack_user_id }}",
            "text": "={{ $json.fallback_text }}",
            "blocks": "={{ $json.blocks }}",
            "unfurl_links": false,
            "unfurl_media": false
          }
        },
        "options": {}
      }
    },
    {
      "id": "call-slack-channel",
      "name": "Send to Channel",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [940, 220],
      "parameters": {
        "workflowId": {"__rl": true, "mode": "id", "value": "xbFJVyUFvGfUbY4s"},
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "action": "post_message",
            "channel_id": "={{ $json.channel_id }}",
            "text": "={{ $json.fallback_text }}",
            "blocks": "={{ $json.blocks }}",
            "unfurl_links": false,
            "unfurl_media": false
          }
        },
        "options": {}
      }
    },
    {
      "id": "call-slack-thread",
      "name": "Reply in Thread",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [940, 380],
      "parameters": {
        "workflowId": {"__rl": true, "mode": "id", "value": "xbFJVyUFvGfUbY4s"},
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "action": "post_thread",
            "channel_id": "={{ $json.channel_id }}",
            "thread_ts": "={{ $json.thread_ts }}",
            "text": "={{ $json.fallback_text }}",
            "blocks": "={{ $json.blocks }}",
            "unfurl_links": false,
            "unfurl_media": false
          }
        },
        "options": {}
      }
    },
    {
      "id": "call-slack-fallback",
      "name": "Fallback to DM",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [940, 540],
      "parameters": {
        "workflowId": {"__rl": true, "mode": "id", "value": "xbFJVyUFvGfUbY4s"},
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "action": "post_message",
            "user_id": "={{ $json.slack_user_id }}",
            "text": "={{ $json.fallback_text }}",
            "blocks": "={{ $json.blocks }}",
            "unfurl_links": false,
            "unfurl_media": false
          }
        },
        "options": {}
      }
    }
  ],
  "connections": {
    "Build Block Kit Message": {"main": [[{"node": "Route by Type", "type": "main", "index": 0}]]},
    "Workflow Input": {"main": [[{"node": "Format for Slack", "type": "main", "index": 0}]]},
    "Format for Slack": {"main": [[{"node": "Build Block Kit Message", "type": "main", "index": 0}]]},
    "Route by Type": {
      "main": [
        [{"node": "Send DM", "type": "main", "index": 0}],
        [{"node": "Send to Channel", "type": "main", "index": 0}],
        [{"node": "Reply in Thread", "type": "main", "index": 0}],
        [{"node": "Fallback to DM", "type": "main", "index": 0}]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": null,
  "versionId": "78153239-3253-46ac-a3a7-318132d58153",
  "activeVersionId": "78153239-3253-46ac-a3a7-318132d58153",
  "versionCounter": 56,
  "triggerCount": 0,
  "tags": []
}
