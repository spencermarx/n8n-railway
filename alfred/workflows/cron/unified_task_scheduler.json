{
  "id": "RUHxLZdoh1kNNXvs",
  "name": "\ud83d\udd50 CRON | Unified Task Scheduler",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Every 5 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        256,
        416
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM alfred.get_due_scheduled_tasks();",
        "options": {}
      },
      "id": "get-due-tasks",
      "name": "Get Due Tasks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        480,
        416
      ],
      "credentials": {
        "postgres": {
          "id": "8nTSHxonyIBczkvN",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.task_id }}",
              "rightValue": "",
              "operator": {
                "type": "number",
                "operation": "exists"
              },
              "id": "condition-1770198420208-dsp774pvv"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-tasks",
      "name": "Any Tasks Due?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        704,
        416
      ]
    },
    {
      "parameters": {},
      "id": "no-tasks",
      "name": "No Tasks Due",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        928,
        512
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "loop-tasks",
      "name": "Loop Tasks",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        928,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "// Read task data from the loop batch item (NOT from $input which is Fetch Notified Events query result)\nconst task = $('Loop Tasks').first().json;\n\n// Build channel-specific delivery instructions\nconst channels = task.channels || ['slack'];\n\nlet fullRequest = task.request;\n\n// =============================================================================\n// UNIVERSAL DATE/TIME INJECTION\n// Compute current date/time in user's timezone deterministically\n// so downstream LLMs never need to guess what \"today\" means.\n// =============================================================================\nconst now = new Date();\nconst userTz = task.user_timezone || 'UTC';\nconst dateFormatter = new Intl.DateTimeFormat('en-US', {\n  timeZone: userTz,\n  weekday: 'long',\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n});\nconst timeFormatter = new Intl.DateTimeFormat('en-US', {\n  timeZone: userTz,\n  hour: '2-digit',\n  minute: '2-digit',\n  hour12: true,\n});\nconst currentDate = dateFormatter.format(now);\nconst currentTime = timeFormatter.format(now);\n\nfullRequest += `\\n\\nCURRENT DATE/TIME (deterministic \u2014 always use this, NEVER guess the date):\\n- Date: ${currentDate}\\n- Time: ${currentTime}\\n- Timezone: ${userTz}`;\n\n// For calendar/meeting-related tasks, inject exact timestamps so the LLM\n// doesn't need to compute them (smaller models get time math wrong)\nconst taskNameLower = task.task_name.toLowerCase();\nconst isCalendarTask = taskNameLower.includes('meeting') || taskNameLower.includes('reminder') || taskNameLower.includes('prep') || taskNameLower.includes('calendar');\n\nif (isCalendarTask) {\n  const plus30 = new Date(now.getTime() + 30 * 60 * 1000);\n  const nowISO = now.toISOString();\n  const plus30ISO = plus30.toISOString();\n  fullRequest += `\\n\\nEXACT TIMESTAMPS FOR CALENDAR QUERY (use these, do NOT compute your own):\\n- time_min: ${nowISO}\\n- time_max: ${plus30ISO}\\n- calendar_id: primary`;\n}\n\n// Read notified event IDs from the Fetch Notified Events DB query\nlet notifiedEventIds = [];\ntry {\n  const notifiedResult = $('Fetch Notified Events').first().json;\n  const ids = notifiedResult.notified_ids;\n  // Handle both array and null/empty results\n  if (Array.isArray(ids)) {\n    notifiedEventIds = ids.filter(id => id && id !== '');\n  }\n} catch (e) {\n  // Fetch Notified Events might not have run or errored\n  notifiedEventIds = [];\n}\n\n// If there are previously notified events, add hard dedup context\nif (notifiedEventIds.length > 0 && isCalendarTask) {\n  fullRequest += `\\n\\nCRITICAL DEDUP \u2014 These calendar event IDs have ALREADY been notified today. Do NOT mention or notify about them again, even if they appear in your calendar query results. Skip them completely:\\n${notifiedEventIds.join('\\n')}`;\n}\n\nreturn [{\n  json: {\n    task_id: task.task_id,\n    user_id: task.user_id,\n    slack_user_id: task.slack_user_id,\n    slack_username: task.slack_username,\n    email: task.email,\n    user_timezone: task.user_timezone,\n    task_name: task.task_name,\n    request: fullRequest,\n    channels: channels,\n    schedule_type: task.schedule_type,\n    run_count: task.run_count,\n    metadata: task.metadata || {}\n  }\n}];"
      },
      "id": "prepare-request",
      "name": "Prepare Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1152,
        240
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "KJpZBr3isT66Rzoa"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "slack_user_id": "={{ $json.slack_user_id }}",
            "message": "={{ $json.request }}",
            "response_type": "dm"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "slack_user_id",
              "displayName": "slack_user_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "message",
              "displayName": "message",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "channel_id",
              "displayName": "channel_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "thread_ts",
              "displayName": "thread_ts",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "response_type",
              "displayName": "response_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "call-alfred",
      "name": "Call Alfred Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1376,
        240
      ],
      "retryOnFail": false,
      "maxTries": 1,
      "waitBetweenTries": 10000
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT alfred.mark_task_run({{ $('Prepare Request').item.json.task_id }}, true, NULL);",
        "options": {}
      },
      "id": "mark-complete",
      "name": "Mark Task Complete",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1600,
        240
      ],
      "credentials": {
        "postgres": {
          "id": "8nTSHxonyIBczkvN",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Simply pass through to continue the loop\nreturn [{ json: { processed: true } }];"
      },
      "id": "loop-done",
      "name": "Loop Done Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1824,
        320
      ]
    },
    {
      "id": "fetch-notified-events",
      "name": "Fetch Notified Events",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1040,
        240
      ],
      "credentials": {
        "postgres": {
          "id": "8nTSHxonyIBczkvN",
          "name": "Postgres account"
        }
      },
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COALESCE(array_agg(event_id), ARRAY[]::text[]) as notified_ids\nFROM alfred.event_notifications\nWHERE user_id = {{ $json.user_id }}::integer\n  AND notification_date = CURRENT_DATE",
        "options": {}
      },
      "alwaysOutputData": false,
      "onError": "continueRegularOutput"
    }
  ],
  "connections": {
    "Every 5 Minutes": {
      "main": [
        [
          {
            "node": "Get Due Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Due Tasks": {
      "main": [
        [
          {
            "node": "Any Tasks Due?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Any Tasks Due?": {
      "main": [
        [
          {
            "node": "Loop Tasks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Tasks Due",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Tasks": {
      "main": [
        [],
        [
          {
            "node": "Fetch Notified Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Request": {
      "main": [
        [
          {
            "node": "Call Alfred Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Alfred Agent": {
      "main": [
        [
          {
            "node": "Mark Task Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Task Complete": {
      "main": [
        [
          {
            "node": "Loop Done Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Done Check": {
      "main": [
        [
          {
            "node": "Loop Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Notified Events": {
      "main": [
        [
          {
            "node": "Prepare Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "node:Every 5 Minutes": {
      "recurrenceRules": []
    }
  },
  "pinData": {
    "Every 5 Minutes": [
      {
        "json": {
          "timestamp": "2026-02-07T09:33:58.565-05:00",
          "Readable date": "February 7th 2026, 9:33:58 am",
          "Readable time": "9:33:58 am",
          "Day of week": "Saturday",
          "Year": "2026",
          "Month": "February",
          "Day of month": "07",
          "Hour": "09",
          "Minute": "33",
          "Second": "58",
          "Timezone": "America/New_York (UTC-05:00)"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "activeVersionId": "4b023a8a-aba4-4ddb-8e01-a7dcc5077fda",
  "versionCounter": 59,
  "triggerCount": 1,
  "tags": [
    {
      "updatedAt": "2026-02-02T22:22:12.832Z",
      "createdAt": "2026-02-02T22:22:12.832Z",
      "id": "Mc3pfpEPBuqRAjiH",
      "name": "CRON"
    }
  ],
  "activeVersion": {
    "updatedAt": "2026-02-11T10:21:34.482Z",
    "createdAt": "2026-02-11T10:21:34.482Z",
    "versionId": "4b023a8a-aba4-4ddb-8e01-a7dcc5077fda",
    "workflowId": "RUHxLZdoh1kNNXvs",
    "nodes": [
      {
        "parameters": {
          "rule": {
            "interval": [
              {
                "field": "minutes"
              }
            ]
          }
        },
        "id": "schedule-trigger",
        "name": "Every 5 Minutes",
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1.3,
        "position": [
          256,
          416
        ]
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT * FROM alfred.get_due_scheduled_tasks();",
          "options": {}
        },
        "id": "get-due-tasks",
        "name": "Get Due Tasks",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.6,
        "position": [
          480,
          416
        ],
        "credentials": {
          "postgres": {
            "id": "8nTSHxonyIBczkvN",
            "name": "Postgres account"
          }
        }
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 3,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "conditions": [
              {
                "leftValue": "={{ $json.task_id }}",
                "rightValue": "",
                "operator": {
                  "type": "number",
                  "operation": "exists"
                },
                "id": "condition-1770198420208-dsp774pvv"
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "check-tasks",
        "name": "Any Tasks Due?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          704,
          416
        ]
      },
      {
        "parameters": {},
        "id": "no-tasks",
        "name": "No Tasks Due",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          928,
          512
        ]
      },
      {
        "parameters": {
          "options": {}
        },
        "id": "loop-tasks",
        "name": "Loop Tasks",
        "type": "n8n-nodes-base.splitInBatches",
        "typeVersion": 3,
        "position": [
          928,
          320
        ]
      },
      {
        "parameters": {
          "jsCode": "// Read task data from the loop batch item (NOT from $input which is Fetch Notified Events query result)\nconst task = $('Loop Tasks').first().json;\n\n// Build channel-specific delivery instructions\nconst channels = task.channels || ['slack'];\n\nlet fullRequest = task.request;\n\n// =============================================================================\n// UNIVERSAL DATE/TIME INJECTION\n// Compute current date/time in user's timezone deterministically\n// so downstream LLMs never need to guess what \"today\" means.\n// =============================================================================\nconst now = new Date();\nconst userTz = task.user_timezone || 'UTC';\nconst dateFormatter = new Intl.DateTimeFormat('en-US', {\n  timeZone: userTz,\n  weekday: 'long',\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n});\nconst timeFormatter = new Intl.DateTimeFormat('en-US', {\n  timeZone: userTz,\n  hour: '2-digit',\n  minute: '2-digit',\n  hour12: true,\n});\nconst currentDate = dateFormatter.format(now);\nconst currentTime = timeFormatter.format(now);\n\nfullRequest += `\\n\\nCURRENT DATE/TIME (deterministic \u2014 always use this, NEVER guess the date):\\n- Date: ${currentDate}\\n- Time: ${currentTime}\\n- Timezone: ${userTz}`;\n\n// For calendar/meeting-related tasks, inject exact timestamps so the LLM\n// doesn't need to compute them (smaller models get time math wrong)\nconst taskNameLower = task.task_name.toLowerCase();\nconst isCalendarTask = taskNameLower.includes('meeting') || taskNameLower.includes('reminder') || taskNameLower.includes('prep') || taskNameLower.includes('calendar');\n\nif (isCalendarTask) {\n  const plus30 = new Date(now.getTime() + 30 * 60 * 1000);\n  const nowISO = now.toISOString();\n  const plus30ISO = plus30.toISOString();\n  fullRequest += `\\n\\nEXACT TIMESTAMPS FOR CALENDAR QUERY (use these, do NOT compute your own):\\n- time_min: ${nowISO}\\n- time_max: ${plus30ISO}\\n- calendar_id: primary`;\n}\n\n// Read notified event IDs from the Fetch Notified Events DB query\nlet notifiedEventIds = [];\ntry {\n  const notifiedResult = $('Fetch Notified Events').first().json;\n  const ids = notifiedResult.notified_ids;\n  // Handle both array and null/empty results\n  if (Array.isArray(ids)) {\n    notifiedEventIds = ids.filter(id => id && id !== '');\n  }\n} catch (e) {\n  // Fetch Notified Events might not have run or errored\n  notifiedEventIds = [];\n}\n\n// If there are previously notified events, add hard dedup context\nif (notifiedEventIds.length > 0 && isCalendarTask) {\n  fullRequest += `\\n\\nCRITICAL DEDUP \u2014 These calendar event IDs have ALREADY been notified today. Do NOT mention or notify about them again, even if they appear in your calendar query results. Skip them completely:\\n${notifiedEventIds.join('\\n')}`;\n}\n\nreturn [{\n  json: {\n    task_id: task.task_id,\n    user_id: task.user_id,\n    slack_user_id: task.slack_user_id,\n    slack_username: task.slack_username,\n    email: task.email,\n    user_timezone: task.user_timezone,\n    task_name: task.task_name,\n    request: fullRequest,\n    channels: channels,\n    schedule_type: task.schedule_type,\n    run_count: task.run_count,\n    metadata: task.metadata || {}\n  }\n}];"
        },
        "id": "prepare-request",
        "name": "Prepare Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1152,
          240
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "KJpZBr3isT66Rzoa"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "slack_user_id": "={{ $json.slack_user_id }}",
              "message": "={{ $json.request }}",
              "response_type": "dm"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "slack_user_id",
                "displayName": "slack_user_id",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "message",
                "displayName": "message",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "channel_id",
                "displayName": "channel_id",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "thread_ts",
                "displayName": "thread_ts",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "response_type",
                "displayName": "response_type",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "call-alfred",
        "name": "Call Alfred Agent",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          1376,
          240
        ],
        "retryOnFail": false,
        "maxTries": 1,
        "waitBetweenTries": 10000
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "=SELECT alfred.mark_task_run({{ $('Prepare Request').item.json.task_id }}, true, NULL);",
          "options": {}
        },
        "id": "mark-complete",
        "name": "Mark Task Complete",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.6,
        "position": [
          1600,
          240
        ],
        "credentials": {
          "postgres": {
            "id": "8nTSHxonyIBczkvN",
            "name": "Postgres account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Simply pass through to continue the loop\nreturn [{ json: { processed: true } }];"
        },
        "id": "loop-done",
        "name": "Loop Done Check",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1824,
          320
        ]
      },
      {
        "id": "fetch-notified-events",
        "name": "Fetch Notified Events",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          1040,
          240
        ],
        "credentials": {
          "postgres": {
            "id": "8nTSHxonyIBczkvN",
            "name": "Postgres account"
          }
        },
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT COALESCE(array_agg(event_id), ARRAY[]::text[]) as notified_ids\nFROM alfred.event_notifications\nWHERE user_id = {{ $json.user_id }}::integer\n  AND notification_date = CURRENT_DATE",
          "options": {}
        },
        "alwaysOutputData": false,
        "onError": "continueRegularOutput"
      }
    ],
    "connections": {
      "Every 5 Minutes": {
        "main": [
          [
            {
              "node": "Get Due Tasks",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Due Tasks": {
        "main": [
          [
            {
              "node": "Any Tasks Due?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Any Tasks Due?": {
        "main": [
          [
            {
              "node": "Loop Tasks",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "No Tasks Due",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Loop Tasks": {
        "main": [
          [],
          [
            {
              "node": "Fetch Notified Events",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Request": {
        "main": [
          [
            {
              "node": "Call Alfred Agent",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call Alfred Agent": {
        "main": [
          [
            {
              "node": "Mark Task Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Task Complete": {
        "main": [
          [
            {
              "node": "Loop Done Check",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Loop Done Check": {
        "main": [
          [
            {
              "node": "Loop Tasks",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Notified Events": {
        "main": [
          [
            {
              "node": "Prepare Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Spencer Marx",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-11T10:21:34.797Z",
        "id": 586,
        "workflowId": "RUHxLZdoh1kNNXvs",
        "versionId": "4b023a8a-aba4-4ddb-8e01-a7dcc5077fda",
        "event": "activated",
        "userId": "e498ff06-ba9d-4721-8454-492195be8229"
      }
    ]
  }
}
