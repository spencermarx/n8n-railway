{
  "updatedAt": "2026-02-05T12:12:14.181Z",
  "createdAt": "2026-02-04T09:42:14.888Z",
  "id": "GVUVTmfFfdIpApKq",
  "name": "ðŸ“… Tool | Scheduled Tasks",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "id": "trigger",
      "name": "Workflow Input",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [250, 300],
      "parameters": {
        "workflowInputs": {
          "values": [
            { "name": "slack_user_id", "type": "string" },
            { "name": "action", "type": "string" },
            { "name": "task_id", "type": "string" },
            { "name": "name", "type": "string" },
            { "name": "request", "type": "string" },
            { "name": "schedule_type", "type": "string" },
            { "name": "scheduled_time", "type": "string" },
            { "name": "days_of_week", "type": "string" },
            { "name": "interval_minutes", "type": "string" },
            { "name": "one_time_at", "type": "string" },
            { "name": "channels", "type": "string" },
            { "name": "is_active", "type": "string" }
          ]
        }
      }
    },
    {
      "id": "get-user",
      "name": "Get User",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [450, 300],
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, slack_user_id, preferences->>'timezone' as timezone FROM alfred.users WHERE slack_user_id = '{{ $json.slack_user_id }}'",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "route-action",
      "name": "Route by Action",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [650, 300],
      "parameters": {
        "mode": "rules",
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $('Workflow Input').item.json.action }}",
                    "rightValue": "create",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "create"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $('Workflow Input').item.json.action }}",
                    "rightValue": "list",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "list"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $('Workflow Input').item.json.action }}",
                    "rightValue": "update",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "update"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $('Workflow Input').item.json.action }}",
                    "rightValue": "delete",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "delete"
            }
          ]
        },
        "options": { "fallbackOutput": "extra" }
      }
    },
    {
      "id": "create-task",
      "name": "Create Task",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 100],
      "parameters": {
        "jsCode": "const input = $('Workflow Input').item.json;\nconst user = $('Get User').first().json;\n\nif (!user.id) {\n  return [{ json: { success: false, error: 'User not found' } }];\n}\n\nconst timezone = user.timezone || 'America/New_York';\nconst channels = input.channels ? input.channels.split(',').map(c => c.trim()) : ['slack'];\n\n// Parse days_of_week if provided (e.g., \"1,2,3,4,5\" for weekdays)\nlet daysOfWeek = null;\nif (input.days_of_week) {\n  daysOfWeek = input.days_of_week.split(',').map(d => parseInt(d.trim()));\n}\n\n// SMART REQUEST ANALYSIS\n// Detect task type and intent from the request to generate robust configurations\nconst requestLower = (input.request || '').toLowerCase();\nconst nameLower = (input.name || '').toLowerCase();\n\n// Task type detection\nconst isMeetingReminder = \n  requestLower.includes('meeting') || \n  requestLower.includes('calendar') || \n  requestLower.includes('event') ||\n  requestLower.includes('block') ||\n  requestLower.includes('upcoming') ||\n  nameLower.includes('reminder') ||\n  nameLower.includes('meeting') ||\n  nameLower.includes('prep');\n\nconst isDailySummary = \n  requestLower.includes('daily') || \n  requestLower.includes('summary') || \n  requestLower.includes('morning') ||\n  nameLower.includes('daily');\n\nconst isOneTimeTask = input.schedule_type === 'once' || input.one_time_at;\n\n// Determine schedule type intelligently\nlet scheduleType = input.schedule_type;\nlet intervalMinutes = input.interval_minutes ? parseInt(input.interval_minutes) : null;\nlet scheduledTime = input.scheduled_time || null;\nlet oneTimeAt = input.one_time_at || null;\n\n// SMART DEFAULTS based on task type\nif (!scheduleType) {\n  if (isOneTimeTask) {\n    scheduleType = 'once';\n  } else if (isDailySummary) {\n    scheduleType = 'daily';\n    scheduledTime = scheduledTime || '08:00';\n  } else if (isMeetingReminder) {\n    scheduleType = 'interval';\n    intervalMinutes = intervalMinutes || 5; // Check every 5 min for meeting reminders\n  } else {\n    scheduleType = 'daily';\n    scheduledTime = scheduledTime || '09:00';\n  }\n}\n\n// SMART REQUEST ENHANCEMENT\n// Rewrite problematic request patterns to be more robust\nlet enhancedRequest = input.request;\n\nif (isMeetingReminder && scheduleType === 'interval') {\n  // Check for problematic patterns like \"15-30 minutes\" or narrow windows\n  const narrowWindowPattern = /\\b(\\d+)\\s*-\\s*(\\d+)\\s*minutes?/i;\n  const match = enhancedRequest.match(narrowWindowPattern);\n  \n  if (match) {\n    // Replace narrow window with simpler \"next 30 minutes\" approach\n    const maxMinutes = Math.max(parseInt(match[1]), parseInt(match[2]));\n    enhancedRequest = enhancedRequest.replace(narrowWindowPattern, `next ${maxMinutes} minutes`);\n  }\n  \n  // Ensure the request has proper \"no action\" clause\n  if (!enhancedRequest.toLowerCase().includes('no action') && \n      !enhancedRequest.toLowerCase().includes('do not send') &&\n      !enhancedRequest.toLowerCase().includes('take no action')) {\n    enhancedRequest += '\\n\\nIf there are no upcoming events in the time window, take no action and do not send any message.';\n  }\n  \n  // Ensure deduplication instruction\n  if (!enhancedRequest.toLowerCase().includes('already been notified') &&\n      !enhancedRequest.toLowerCase().includes('not already')) {\n    enhancedRequest = enhancedRequest.replace(\n      /for (any |each |every )?upcoming event/i,\n      'for each upcoming event that I have NOT already been notified about today'\n    );\n  }\n}\n\n// INTERVAL GUARDRAILS\nif (scheduleType === 'interval' && intervalMinutes !== null) {\n  const MIN_INTERVAL = 5;\n  const MAX_INTERVAL = 1440; // 24 hours\n  \n  if (intervalMinutes < MIN_INTERVAL) {\n    intervalMinutes = MIN_INTERVAL;\n  }\n  if (intervalMinutes > MAX_INTERVAL) {\n    intervalMinutes = MAX_INTERVAL;\n  }\n}\n\n// Initialize metadata for event-based tasks\nlet metadata = {};\nif (isMeetingReminder) {\n  metadata = {\n    notified_event_ids: [],\n    last_reset: null,\n    task_type: 'meeting_reminder'\n  };\n} else if (isDailySummary) {\n  metadata = {\n    task_type: 'daily_summary'\n  };\n} else {\n  metadata = {\n    task_type: 'general'\n  };\n}\n\n// Generate smart task name if not provided\nlet taskName = input.name;\nif (!taskName || taskName === 'Scheduled Task') {\n  if (isMeetingReminder) {\n    taskName = 'Meeting Prep Reminder';\n  } else if (isDailySummary) {\n    taskName = 'Daily Schedule Summary';\n  } else {\n    taskName = 'Scheduled Task';\n  }\n}\n\nreturn [{\n  json: {\n    user_id: user.id,\n    timezone: timezone,\n    name: taskName,\n    request: enhancedRequest,\n    schedule_type: scheduleType,\n    scheduled_time: scheduledTime,\n    days_of_week: daysOfWeek,\n    interval_minutes: intervalMinutes,\n    one_time_at: oneTimeAt,\n    channels: channels,\n    metadata: metadata,\n    _analysis: {\n      detected_type: isMeetingReminder ? 'meeting_reminder' : (isDailySummary ? 'daily_summary' : 'general'),\n      request_enhanced: enhancedRequest !== input.request\n    }\n  }\n}];"
      }
    },
    {
      "id": "insert-task",
      "name": "Insert Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1100, 100],
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO alfred.scheduled_tasks (\n  user_id, name, request, schedule_type, \n  scheduled_time, days_of_week, interval_minutes, one_time_at,\n  channels, next_run_at\n) VALUES (\n  {{ $json.user_id }},\n  '{{ $json.name.replace(/'/g, \"''\") }}',\n  '{{ $json.request.replace(/'/g, \"''\") }}',\n  '{{ $json.schedule_type }}',\n  {{ $json.scheduled_time ? \"'\" + $json.scheduled_time + \"'\" : 'NULL' }},\n  {{ $json.days_of_week ? \"ARRAY[\" + $json.days_of_week.join(',') + \"]\" : 'NULL' }},\n  {{ $json.interval_minutes || 'NULL' }},\n  {{ $json.one_time_at ? \"'\" + $json.one_time_at + \"'\" : 'NULL' }},\n  ARRAY[{{ $json.channels.map(c => \"'\" + c + \"'\").join(',') }}],\n  alfred.calculate_next_run(\n    '{{ $json.schedule_type }}',\n    '{{ $json.timezone }}',\n    {{ $json.one_time_at ? \"'\" + $json.one_time_at + \"'::timestamptz\" : 'NULL' }},\n    {{ $json.scheduled_time ? \"'\" + $json.scheduled_time + \"'::time\" : 'NULL' }},\n    {{ $json.days_of_week ? \"ARRAY[\" + $json.days_of_week.join(',') + \"]\" : 'NULL' }},\n    {{ $json.interval_minutes || 'NULL' }},\n    NULL\n  )\n)\nRETURNING id, name, schedule_type, scheduled_time, days_of_week, interval_minutes, channels, next_run_at;",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "format-create",
      "name": "Format Create Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 100],
      "parameters": {
        "jsCode": "const task = $input.first().json;\n\nlet scheduleDesc = '';\nswitch (task.schedule_type) {\n  case 'daily':\n    scheduleDesc = `daily at ${task.scheduled_time}`;\n    break;\n  case 'weekly':\n    const dayNames = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\n    const days = task.days_of_week.map(d => dayNames[d]).join(', ');\n    scheduleDesc = `every ${days} at ${task.scheduled_time}`;\n    break;\n  case 'interval':\n    scheduleDesc = `every ${task.interval_minutes} minutes`;\n    break;\n  case 'once':\n    scheduleDesc = `once at ${task.next_run_at}`;\n    break;\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'create',\n    task: {\n      id: task.id,\n      name: task.name,\n      schedule: scheduleDesc,\n      channels: task.channels,\n      next_run: task.next_run_at\n    },\n    message: `Created scheduled task \"${task.name}\" to run ${scheduleDesc} via ${task.channels.join(' and ')}.`\n  }\n}];"
      }
    },
    {
      "id": "list-tasks",
      "name": "List Tasks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 240],
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id, name, request, schedule_type, scheduled_time, \n  days_of_week, interval_minutes, channels, \n  is_active, next_run_at, last_run_at, run_count\nFROM alfred.scheduled_tasks\nWHERE user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nORDER BY is_active DESC, next_run_at ASC;",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "format-list",
      "name": "Format List Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 240],
      "parameters": {
        "jsCode": "const tasks = $input.all().map(item => item.json);\n\nif (tasks.length === 0 || !tasks[0].id) {\n  return [{\n    json: {\n      success: true,\n      action: 'list',\n      tasks: [],\n      message: 'You have no scheduled tasks.'\n    }\n  }];\n}\n\nconst dayNames = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];\n\nconst formattedTasks = tasks.map(t => {\n  let scheduleDesc = '';\n  switch (t.schedule_type) {\n    case 'daily':\n      scheduleDesc = `Daily at ${t.scheduled_time}`;\n      break;\n    case 'weekly':\n      const days = t.days_of_week ? t.days_of_week.map(d => dayNames[d]).join(', ') : '';\n      scheduleDesc = `${days} at ${t.scheduled_time}`;\n      break;\n    case 'interval':\n      scheduleDesc = `Every ${t.interval_minutes} min`;\n      break;\n    case 'once':\n      scheduleDesc = `Once at ${t.next_run_at}`;\n      break;\n  }\n  \n  return {\n    id: t.id,\n    name: t.name,\n    schedule: scheduleDesc,\n    channels: t.channels,\n    active: t.is_active,\n    next_run: t.next_run_at,\n    run_count: t.run_count\n  };\n});\n\nconst activeCount = formattedTasks.filter(t => t.active).length;\n\nreturn [{\n  json: {\n    success: true,\n    action: 'list',\n    tasks: formattedTasks,\n    message: `You have ${formattedTasks.length} scheduled task(s) (${activeCount} active).`\n  }\n}];"
      }
    },
    {
      "id": "update-task",
      "name": "Update Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 380],
      "parameters": {
        "operation": "executeQuery",
        "query": "=UPDATE alfred.scheduled_tasks SET\n  {{ $('Workflow Input').item.json.name ? \"name = '\" + $('Workflow Input').item.json.name.replace(/'/g, \"''\") + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.request ? \"request = '\" + $('Workflow Input').item.json.request.replace(/'/g, \"''\") + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.scheduled_time ? \"scheduled_time = '\" + $('Workflow Input').item.json.scheduled_time + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.is_active !== undefined ? \"is_active = \" + ($('Workflow Input').item.json.is_active === 'true' || $('Workflow Input').item.json.is_active === true) + \",\" : '' }}\n  updated_at = NOW()\nWHERE id = {{ $('Workflow Input').item.json.task_id }}\n  AND user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nRETURNING id, name, is_active;",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "format-update",
      "name": "Format Update Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 380],
      "parameters": {
        "jsCode": "const result = $input.first().json;\n\nif (!result.id) {\n  return [{\n    json: {\n      success: false,\n      action: 'update',\n      error: 'Task not found or you do not have permission to update it.'\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'update',\n    task: result,\n    message: `Updated task \"${result.name}\" successfully.`\n  }\n}];"
      }
    },
    {
      "id": "delete-task",
      "name": "Delete Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 520],
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM alfred.scheduled_tasks\nWHERE id = {{ $('Workflow Input').item.json.task_id }}\n  AND user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nRETURNING id, name;",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "format-delete",
      "name": "Format Delete Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 520],
      "parameters": {
        "jsCode": "const result = $input.first().json;\n\nif (!result.id) {\n  return [{\n    json: {\n      success: false,\n      action: 'delete',\n      error: 'Task not found or you do not have permission to delete it.'\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'delete',\n    message: `Deleted task \"${result.name}\" successfully.`\n  }\n}];"
      }
    },
    {
      "id": "invalid-action",
      "name": "Invalid Action",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [900, 660],
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "success",
              "name": "success",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "error",
              "name": "error",
              "value": "={{ 'Invalid action: ' + $('Workflow Input').item.json.action + '. Valid actions: create, list, update, delete' }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      }
    }
  ],
  "connections": {
    "Workflow Input": {
      "main": [[{ "node": "Get User", "type": "main", "index": 0 }]]
    },
    "Get User": {
      "main": [[{ "node": "Route by Action", "type": "main", "index": 0 }]]
    },
    "Route by Action": {
      "main": [
        [{ "node": "Create Task", "type": "main", "index": 0 }],
        [{ "node": "List Tasks", "type": "main", "index": 0 }],
        [{ "node": "Update Task", "type": "main", "index": 0 }],
        [{ "node": "Delete Task", "type": "main", "index": 0 }],
        [{ "node": "Invalid Action", "type": "main", "index": 0 }]
      ]
    },
    "Create Task": {
      "main": [[{ "node": "Insert Task", "type": "main", "index": 0 }]]
    },
    "Insert Task": {
      "main": [[{ "node": "Format Create Response", "type": "main", "index": 0 }]]
    },
    "List Tasks": {
      "main": [[{ "node": "Format List Response", "type": "main", "index": 0 }]]
    },
    "Update Task": {
      "main": [[{ "node": "Format Update Response", "type": "main", "index": 0 }]]
    },
    "Delete Task": {
      "main": [[{ "node": "Format Delete Response", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": null,
  "versionId": "c018831d-ef05-4af1-beee-7ce6cc17dcd6",
  "activeVersionId": "c018831d-ef05-4af1-beee-7ce6cc17dcd6",
  "versionCounter": 16,
  "triggerCount": 0,
  "tags": []
}
