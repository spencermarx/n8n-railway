{
  "updatedAt": "2026-02-04T12:12:31.808Z",
  "createdAt": "2026-02-04T09:42:14.888Z",
  "id": "GVUVTmfFfdIpApKq",
  "name": "ðŸ“… Tool | Scheduled Tasks",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "id": "trigger",
      "name": "Workflow Input",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [250, 300],
      "parameters": {
        "workflowInputs": {
          "values": [
            { "name": "slack_user_id", "type": "string" },
            { "name": "action", "type": "string" },
            { "name": "task_id", "type": "string" },
            { "name": "name", "type": "string" },
            { "name": "request", "type": "string" },
            { "name": "schedule_type", "type": "string" },
            { "name": "scheduled_time", "type": "string" },
            { "name": "days_of_week", "type": "string" },
            { "name": "interval_minutes", "type": "string" },
            { "name": "one_time_at", "type": "string" },
            { "name": "channels", "type": "string" },
            { "name": "is_active", "type": "string" }
          ]
        }
      }
    },
    {
      "id": "get-user",
      "name": "Get User",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [450, 300],
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, slack_user_id, preferences->>'timezone' as timezone FROM alfred.users WHERE slack_user_id = '{{ $json.slack_user_id }}'",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "route-action",
      "name": "Route by Action",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [650, 300],
      "parameters": {
        "mode": "rules",
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $('Workflow Input').item.json.action }}",
                    "rightValue": "create",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "create"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $('Workflow Input').item.json.action }}",
                    "rightValue": "list",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "list"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $('Workflow Input').item.json.action }}",
                    "rightValue": "update",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "update"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $('Workflow Input').item.json.action }}",
                    "rightValue": "delete",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "delete"
            }
          ]
        },
        "options": { "fallbackOutput": "extra" }
      }
    },
    {
      "id": "create-task",
      "name": "Create Task",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 100],
      "parameters": {
        "jsCode": "const input = $('Workflow Input').item.json;\nconst user = $('Get User').first().json;\n\nif (!user.id) {\n  return [{ json: { success: false, error: 'User not found' } }];\n}\n\nconst scheduleType = input.schedule_type || 'daily';\nconst timezone = user.timezone || 'America/New_York';\nconst channels = input.channels ? input.channels.split(',').map(c => c.trim()) : ['slack'];\n\n// Parse days_of_week if provided (e.g., \"1,2,3,4,5\" for weekdays)\nlet daysOfWeek = null;\nif (input.days_of_week) {\n  daysOfWeek = input.days_of_week.split(',').map(d => parseInt(d.trim()));\n}\n\n// Build the query parts based on schedule_type\nlet scheduledTime = input.scheduled_time || null;\nlet intervalMinutes = input.interval_minutes ? parseInt(input.interval_minutes) : null;\nlet oneTimeAt = input.one_time_at || null;\n\n// SCHEDULING GUARDRAILS:\n// For interval schedules, enforce minimum 5-minute interval to prevent gaps\n// when checking time-based windows (e.g., \"events in next 15-30 min\")\nif (scheduleType === 'interval' && intervalMinutes !== null) {\n  const MIN_INTERVAL = 5;\n  const MAX_INTERVAL = 1440; // 24 hours\n  \n  if (intervalMinutes < MIN_INTERVAL) {\n    intervalMinutes = MIN_INTERVAL;\n  }\n  if (intervalMinutes > MAX_INTERVAL) {\n    intervalMinutes = MAX_INTERVAL;\n  }\n}\n\nreturn [{\n  json: {\n    user_id: user.id,\n    timezone: timezone,\n    name: input.name || 'Scheduled Task',\n    request: input.request,\n    schedule_type: scheduleType,\n    scheduled_time: scheduledTime,\n    days_of_week: daysOfWeek,\n    interval_minutes: intervalMinutes,\n    one_time_at: oneTimeAt,\n    channels: channels\n  }\n}];"
      }
    },
    {
      "id": "insert-task",
      "name": "Insert Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1100, 100],
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO alfred.scheduled_tasks (\n  user_id, name, request, schedule_type, \n  scheduled_time, days_of_week, interval_minutes, one_time_at,\n  channels, next_run_at\n) VALUES (\n  {{ $json.user_id }},\n  '{{ $json.name.replace(/'/g, \"''\") }}',\n  '{{ $json.request.replace(/'/g, \"''\") }}',\n  '{{ $json.schedule_type }}',\n  {{ $json.scheduled_time ? \"'\" + $json.scheduled_time + \"'\" : 'NULL' }},\n  {{ $json.days_of_week ? \"ARRAY[\" + $json.days_of_week.join(',') + \"]\" : 'NULL' }},\n  {{ $json.interval_minutes || 'NULL' }},\n  {{ $json.one_time_at ? \"'\" + $json.one_time_at + \"'\" : 'NULL' }},\n  ARRAY[{{ $json.channels.map(c => \"'\" + c + \"'\").join(',') }}],\n  alfred.calculate_next_run(\n    '{{ $json.schedule_type }}',\n    '{{ $json.timezone }}',\n    {{ $json.one_time_at ? \"'\" + $json.one_time_at + \"'::timestamptz\" : 'NULL' }},\n    {{ $json.scheduled_time ? \"'\" + $json.scheduled_time + \"'::time\" : 'NULL' }},\n    {{ $json.days_of_week ? \"ARRAY[\" + $json.days_of_week.join(',') + \"]\" : 'NULL' }},\n    {{ $json.interval_minutes || 'NULL' }},\n    NULL\n  )\n)\nRETURNING id, name, schedule_type, scheduled_time, days_of_week, interval_minutes, channels, next_run_at;",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "format-create",
      "name": "Format Create Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 100],
      "parameters": {
        "jsCode": "const task = $input.first().json;\n\nlet scheduleDesc = '';\nswitch (task.schedule_type) {\n  case 'daily':\n    scheduleDesc = `daily at ${task.scheduled_time}`;\n    break;\n  case 'weekly':\n    const dayNames = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\n    const days = task.days_of_week.map(d => dayNames[d]).join(', ');\n    scheduleDesc = `every ${days} at ${task.scheduled_time}`;\n    break;\n  case 'interval':\n    scheduleDesc = `every ${task.interval_minutes} minutes`;\n    break;\n  case 'once':\n    scheduleDesc = `once at ${task.next_run_at}`;\n    break;\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'create',\n    task: {\n      id: task.id,\n      name: task.name,\n      schedule: scheduleDesc,\n      channels: task.channels,\n      next_run: task.next_run_at\n    },\n    message: `Created scheduled task \"${task.name}\" to run ${scheduleDesc} via ${task.channels.join(' and ')}.`\n  }\n}];"
      }
    },
    {
      "id": "list-tasks",
      "name": "List Tasks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 240],
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id, name, request, schedule_type, scheduled_time, \n  days_of_week, interval_minutes, channels, \n  is_active, next_run_at, last_run_at, run_count\nFROM alfred.scheduled_tasks\nWHERE user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nORDER BY is_active DESC, next_run_at ASC;",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "format-list",
      "name": "Format List Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 240],
      "parameters": {
        "jsCode": "const tasks = $input.all().map(item => item.json);\n\nif (tasks.length === 0 || !tasks[0].id) {\n  return [{\n    json: {\n      success: true,\n      action: 'list',\n      tasks: [],\n      message: 'You have no scheduled tasks.'\n    }\n  }];\n}\n\nconst dayNames = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];\n\nconst formattedTasks = tasks.map(t => {\n  let scheduleDesc = '';\n  switch (t.schedule_type) {\n    case 'daily':\n      scheduleDesc = `Daily at ${t.scheduled_time}`;\n      break;\n    case 'weekly':\n      const days = t.days_of_week ? t.days_of_week.map(d => dayNames[d]).join(', ') : '';\n      scheduleDesc = `${days} at ${t.scheduled_time}`;\n      break;\n    case 'interval':\n      scheduleDesc = `Every ${t.interval_minutes} min`;\n      break;\n    case 'once':\n      scheduleDesc = `Once at ${t.next_run_at}`;\n      break;\n  }\n  \n  return {\n    id: t.id,\n    name: t.name,\n    schedule: scheduleDesc,\n    channels: t.channels,\n    active: t.is_active,\n    next_run: t.next_run_at,\n    run_count: t.run_count\n  };\n});\n\nconst activeCount = formattedTasks.filter(t => t.active).length;\n\nreturn [{\n  json: {\n    success: true,\n    action: 'list',\n    tasks: formattedTasks,\n    message: `You have ${formattedTasks.length} scheduled task(s) (${activeCount} active).`\n  }\n}];"
      }
    },
    {
      "id": "update-task",
      "name": "Update Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 380],
      "parameters": {
        "operation": "executeQuery",
        "query": "=UPDATE alfred.scheduled_tasks SET\n  {{ $('Workflow Input').item.json.name ? \"name = '\" + $('Workflow Input').item.json.name.replace(/'/g, \"''\") + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.request ? \"request = '\" + $('Workflow Input').item.json.request.replace(/'/g, \"''\") + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.scheduled_time ? \"scheduled_time = '\" + $('Workflow Input').item.json.scheduled_time + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.is_active !== undefined ? \"is_active = \" + ($('Workflow Input').item.json.is_active === 'true' || $('Workflow Input').item.json.is_active === true) + \",\" : '' }}\n  updated_at = NOW()\nWHERE id = {{ $('Workflow Input').item.json.task_id }}\n  AND user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nRETURNING id, name, is_active;",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "format-update",
      "name": "Format Update Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 380],
      "parameters": {
        "jsCode": "const result = $input.first().json;\n\nif (!result.id) {\n  return [{\n    json: {\n      success: false,\n      action: 'update',\n      error: 'Task not found or you do not have permission to update it.'\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'update',\n    task: result,\n    message: `Updated task \"${result.name}\" successfully.`\n  }\n}];"
      }
    },
    {
      "id": "delete-task",
      "name": "Delete Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 520],
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM alfred.scheduled_tasks\nWHERE id = {{ $('Workflow Input').item.json.task_id }}\n  AND user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nRETURNING id, name;",
        "options": {}
      },
      "credentials": {
        "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
      }
    },
    {
      "id": "format-delete",
      "name": "Format Delete Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 520],
      "parameters": {
        "jsCode": "const result = $input.first().json;\n\nif (!result.id) {\n  return [{\n    json: {\n      success: false,\n      action: 'delete',\n      error: 'Task not found or you do not have permission to delete it.'\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'delete',\n    message: `Deleted task \"${result.name}\" successfully.`\n  }\n}];"
      }
    },
    {
      "id": "invalid-action",
      "name": "Invalid Action",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [900, 660],
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "success",
              "name": "success",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "error",
              "name": "error",
              "value": "={{ 'Invalid action: ' + $('Workflow Input').item.json.action + '. Valid actions: create, list, update, delete' }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      }
    }
  ],
  "connections": {
    "Workflow Input": {
      "main": [[{ "node": "Get User", "type": "main", "index": 0 }]]
    },
    "Get User": {
      "main": [[{ "node": "Route by Action", "type": "main", "index": 0 }]]
    },
    "Route by Action": {
      "main": [
        [{ "node": "Create Task", "type": "main", "index": 0 }],
        [{ "node": "List Tasks", "type": "main", "index": 0 }],
        [{ "node": "Update Task", "type": "main", "index": 0 }],
        [{ "node": "Delete Task", "type": "main", "index": 0 }],
        [{ "node": "Invalid Action", "type": "main", "index": 0 }]
      ]
    },
    "Create Task": {
      "main": [[{ "node": "Insert Task", "type": "main", "index": 0 }]]
    },
    "Insert Task": {
      "main": [
        [{ "node": "Format Create Response", "type": "main", "index": 0 }]
      ]
    },
    "List Tasks": {
      "main": [[{ "node": "Format List Response", "type": "main", "index": 0 }]]
    },
    "Update Task": {
      "main": [
        [{ "node": "Format Update Response", "type": "main", "index": 0 }]
      ]
    },
    "Delete Task": {
      "main": [
        [{ "node": "Format Delete Response", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": null,
  "versionId": "851e0a8b-513d-4600-9e6e-c863afc3ade1",
  "activeVersionId": "851e0a8b-513d-4600-9e6e-c863afc3ade1",
  "versionCounter": 12,
  "triggerCount": 0,
  "shared": [
    {
      "updatedAt": "2026-02-04T09:42:14.888Z",
      "createdAt": "2026-02-04T09:42:14.888Z",
      "role": "workflow:owner",
      "workflowId": "GVUVTmfFfdIpApKq",
      "projectId": "Jd992SEPuokf8o5Z",
      "project": {
        "updatedAt": "2026-02-02T12:27:52.037Z",
        "createdAt": "2026-02-02T12:20:35.714Z",
        "id": "Jd992SEPuokf8o5Z",
        "name": "Spencer Marx <spencer@aclarify.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "e498ff06-ba9d-4721-8454-492195be8229",
        "projectRelations": [
          {
            "updatedAt": "2026-02-02T12:20:35.714Z",
            "createdAt": "2026-02-02T12:20:35.714Z",
            "userId": "e498ff06-ba9d-4721-8454-492195be8229",
            "projectId": "Jd992SEPuokf8o5Z",
            "user": {
              "updatedAt": "2026-02-04T21:36:26.759Z",
              "createdAt": "2026-02-02T12:20:29.217Z",
              "id": "e498ff06-ba9d-4721-8454-492195be8229",
              "email": "spencer@aclarify.com",
              "firstName": "Spencer",
              "lastName": "Marx",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2026-02-02T12:28:04.495Z",
                "personalization_survey_n8n_version": "2.6.2",
                "companySize": "<20",
                "companyType": "saas",
                "role": "business-owner",
                "reportedSource": "friend"
              },
              "settings": {
                "userActivated": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "KwXRQi320-E6cSKEUFTol",
                "userActivatedAt": 1770049275864
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-04",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-04T12:12:31.808Z",
    "createdAt": "2026-02-04T12:12:31.808Z",
    "versionId": "851e0a8b-513d-4600-9e6e-c863afc3ade1",
    "workflowId": "GVUVTmfFfdIpApKq",
    "nodes": [
      {
        "id": "trigger",
        "name": "Workflow Input",
        "type": "n8n-nodes-base.executeWorkflowTrigger",
        "typeVersion": 1.1,
        "position": [250, 300],
        "parameters": {
          "workflowInputs": {
            "values": [
              { "name": "slack_user_id", "type": "string" },
              { "name": "action", "type": "string" },
              { "name": "task_id", "type": "string" },
              { "name": "name", "type": "string" },
              { "name": "request", "type": "string" },
              { "name": "schedule_type", "type": "string" },
              { "name": "scheduled_time", "type": "string" },
              { "name": "days_of_week", "type": "string" },
              { "name": "interval_minutes", "type": "string" },
              { "name": "one_time_at", "type": "string" },
              { "name": "channels", "type": "string" },
              { "name": "is_active", "type": "string" }
            ]
          }
        }
      },
      {
        "id": "get-user",
        "name": "Get User",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [450, 300],
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT id, slack_user_id, preferences->>'timezone' as timezone FROM alfred.users WHERE slack_user_id = '{{ $json.slack_user_id }}'",
          "options": {}
        },
        "credentials": {
          "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
        }
      },
      {
        "id": "route-action",
        "name": "Route by Action",
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3.2,
        "position": [650, 300],
        "parameters": {
          "mode": "rules",
          "rules": {
            "values": [
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "leftValue": "={{ $('Workflow Input').item.json.action }}",
                      "rightValue": "create",
                      "operator": { "type": "string", "operation": "equals" }
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "create"
              },
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "leftValue": "={{ $('Workflow Input').item.json.action }}",
                      "rightValue": "list",
                      "operator": { "type": "string", "operation": "equals" }
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "list"
              },
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "leftValue": "={{ $('Workflow Input').item.json.action }}",
                      "rightValue": "update",
                      "operator": { "type": "string", "operation": "equals" }
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "update"
              },
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "leftValue": "={{ $('Workflow Input').item.json.action }}",
                      "rightValue": "delete",
                      "operator": { "type": "string", "operation": "equals" }
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "delete"
              }
            ]
          },
          "options": { "fallbackOutput": "extra" }
        }
      },
      {
        "id": "create-task",
        "name": "Create Task",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [900, 100],
        "parameters": {
          "jsCode": "const input = $('Workflow Input').item.json;\nconst user = $('Get User').first().json;\n\nif (!user.id) {\n  return [{ json: { success: false, error: 'User not found' } }];\n}\n\nconst scheduleType = input.schedule_type || 'daily';\nconst timezone = user.timezone || 'America/New_York';\nconst channels = input.channels ? input.channels.split(',').map(c => c.trim()) : ['slack'];\n\n// Parse days_of_week if provided (e.g., \"1,2,3,4,5\" for weekdays)\nlet daysOfWeek = null;\nif (input.days_of_week) {\n  daysOfWeek = input.days_of_week.split(',').map(d => parseInt(d.trim()));\n}\n\n// Build the query parts based on schedule_type\nlet scheduledTime = input.scheduled_time || null;\nlet intervalMinutes = input.interval_minutes ? parseInt(input.interval_minutes) : null;\nlet oneTimeAt = input.one_time_at || null;\n\n// SCHEDULING GUARDRAILS:\n// For interval schedules, enforce minimum 5-minute interval to prevent gaps\n// when checking time-based windows (e.g., \"events in next 15-30 min\")\nif (scheduleType === 'interval' && intervalMinutes !== null) {\n  const MIN_INTERVAL = 5;\n  const MAX_INTERVAL = 1440; // 24 hours\n  \n  if (intervalMinutes < MIN_INTERVAL) {\n    intervalMinutes = MIN_INTERVAL;\n  }\n  if (intervalMinutes > MAX_INTERVAL) {\n    intervalMinutes = MAX_INTERVAL;\n  }\n}\n\nreturn [{\n  json: {\n    user_id: user.id,\n    timezone: timezone,\n    name: input.name || 'Scheduled Task',\n    request: input.request,\n    schedule_type: scheduleType,\n    scheduled_time: scheduledTime,\n    days_of_week: daysOfWeek,\n    interval_minutes: intervalMinutes,\n    one_time_at: oneTimeAt,\n    channels: channels\n  }\n}];"
        }
      },
      {
        "id": "insert-task",
        "name": "Insert Task",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [1100, 100],
        "parameters": {
          "operation": "executeQuery",
          "query": "INSERT INTO alfred.scheduled_tasks (\n  user_id, name, request, schedule_type, \n  scheduled_time, days_of_week, interval_minutes, one_time_at,\n  channels, next_run_at\n) VALUES (\n  {{ $json.user_id }},\n  '{{ $json.name.replace(/'/g, \"''\") }}',\n  '{{ $json.request.replace(/'/g, \"''\") }}',\n  '{{ $json.schedule_type }}',\n  {{ $json.scheduled_time ? \"'\" + $json.scheduled_time + \"'\" : 'NULL' }},\n  {{ $json.days_of_week ? \"ARRAY[\" + $json.days_of_week.join(',') + \"]\" : 'NULL' }},\n  {{ $json.interval_minutes || 'NULL' }},\n  {{ $json.one_time_at ? \"'\" + $json.one_time_at + \"'\" : 'NULL' }},\n  ARRAY[{{ $json.channels.map(c => \"'\" + c + \"'\").join(',') }}],\n  alfred.calculate_next_run(\n    '{{ $json.schedule_type }}',\n    '{{ $json.timezone }}',\n    {{ $json.one_time_at ? \"'\" + $json.one_time_at + \"'::timestamptz\" : 'NULL' }},\n    {{ $json.scheduled_time ? \"'\" + $json.scheduled_time + \"'::time\" : 'NULL' }},\n    {{ $json.days_of_week ? \"ARRAY[\" + $json.days_of_week.join(',') + \"]\" : 'NULL' }},\n    {{ $json.interval_minutes || 'NULL' }},\n    NULL\n  )\n)\nRETURNING id, name, schedule_type, scheduled_time, days_of_week, interval_minutes, channels, next_run_at;",
          "options": {}
        },
        "credentials": {
          "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
        }
      },
      {
        "id": "format-create",
        "name": "Format Create Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [1300, 100],
        "parameters": {
          "jsCode": "const task = $input.first().json;\n\nlet scheduleDesc = '';\nswitch (task.schedule_type) {\n  case 'daily':\n    scheduleDesc = `daily at ${task.scheduled_time}`;\n    break;\n  case 'weekly':\n    const dayNames = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\n    const days = task.days_of_week.map(d => dayNames[d]).join(', ');\n    scheduleDesc = `every ${days} at ${task.scheduled_time}`;\n    break;\n  case 'interval':\n    scheduleDesc = `every ${task.interval_minutes} minutes`;\n    break;\n  case 'once':\n    scheduleDesc = `once at ${task.next_run_at}`;\n    break;\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'create',\n    task: {\n      id: task.id,\n      name: task.name,\n      schedule: scheduleDesc,\n      channels: task.channels,\n      next_run: task.next_run_at\n    },\n    message: `Created scheduled task \"${task.name}\" to run ${scheduleDesc} via ${task.channels.join(' and ')}.`\n  }\n}];"
        }
      },
      {
        "id": "list-tasks",
        "name": "List Tasks",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [900, 240],
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT \n  id, name, request, schedule_type, scheduled_time, \n  days_of_week, interval_minutes, channels, \n  is_active, next_run_at, last_run_at, run_count\nFROM alfred.scheduled_tasks\nWHERE user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nORDER BY is_active DESC, next_run_at ASC;",
          "options": {}
        },
        "credentials": {
          "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
        }
      },
      {
        "id": "format-list",
        "name": "Format List Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [1100, 240],
        "parameters": {
          "jsCode": "const tasks = $input.all().map(item => item.json);\n\nif (tasks.length === 0 || !tasks[0].id) {\n  return [{\n    json: {\n      success: true,\n      action: 'list',\n      tasks: [],\n      message: 'You have no scheduled tasks.'\n    }\n  }];\n}\n\nconst dayNames = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];\n\nconst formattedTasks = tasks.map(t => {\n  let scheduleDesc = '';\n  switch (t.schedule_type) {\n    case 'daily':\n      scheduleDesc = `Daily at ${t.scheduled_time}`;\n      break;\n    case 'weekly':\n      const days = t.days_of_week ? t.days_of_week.map(d => dayNames[d]).join(', ') : '';\n      scheduleDesc = `${days} at ${t.scheduled_time}`;\n      break;\n    case 'interval':\n      scheduleDesc = `Every ${t.interval_minutes} min`;\n      break;\n    case 'once':\n      scheduleDesc = `Once at ${t.next_run_at}`;\n      break;\n  }\n  \n  return {\n    id: t.id,\n    name: t.name,\n    schedule: scheduleDesc,\n    channels: t.channels,\n    active: t.is_active,\n    next_run: t.next_run_at,\n    run_count: t.run_count\n  };\n});\n\nconst activeCount = formattedTasks.filter(t => t.active).length;\n\nreturn [{\n  json: {\n    success: true,\n    action: 'list',\n    tasks: formattedTasks,\n    message: `You have ${formattedTasks.length} scheduled task(s) (${activeCount} active).`\n  }\n}];"
        }
      },
      {
        "id": "update-task",
        "name": "Update Task",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [900, 380],
        "parameters": {
          "operation": "executeQuery",
          "query": "=UPDATE alfred.scheduled_tasks SET\n  {{ $('Workflow Input').item.json.name ? \"name = '\" + $('Workflow Input').item.json.name.replace(/'/g, \"''\") + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.request ? \"request = '\" + $('Workflow Input').item.json.request.replace(/'/g, \"''\") + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.scheduled_time ? \"scheduled_time = '\" + $('Workflow Input').item.json.scheduled_time + \"',\" : '' }}\n  {{ $('Workflow Input').item.json.is_active !== undefined ? \"is_active = \" + ($('Workflow Input').item.json.is_active === 'true' || $('Workflow Input').item.json.is_active === true) + \",\" : '' }}\n  updated_at = NOW()\nWHERE id = {{ $('Workflow Input').item.json.task_id }}\n  AND user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nRETURNING id, name, is_active;",
          "options": {}
        },
        "credentials": {
          "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
        }
      },
      {
        "id": "format-update",
        "name": "Format Update Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [1100, 380],
        "parameters": {
          "jsCode": "const result = $input.first().json;\n\nif (!result.id) {\n  return [{\n    json: {\n      success: false,\n      action: 'update',\n      error: 'Task not found or you do not have permission to update it.'\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'update',\n    task: result,\n    message: `Updated task \"${result.name}\" successfully.`\n  }\n}];"
        }
      },
      {
        "id": "delete-task",
        "name": "Delete Task",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [900, 520],
        "parameters": {
          "operation": "executeQuery",
          "query": "DELETE FROM alfred.scheduled_tasks\nWHERE id = {{ $('Workflow Input').item.json.task_id }}\n  AND user_id = (SELECT id FROM alfred.users WHERE slack_user_id = '{{ $('Workflow Input').item.json.slack_user_id }}')\nRETURNING id, name;",
          "options": {}
        },
        "credentials": {
          "postgres": { "id": "8nTSHxonyIBczkvN", "name": "Postgres account" }
        }
      },
      {
        "id": "format-delete",
        "name": "Format Delete Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [1100, 520],
        "parameters": {
          "jsCode": "const result = $input.first().json;\n\nif (!result.id) {\n  return [{\n    json: {\n      success: false,\n      action: 'delete',\n      error: 'Task not found or you do not have permission to delete it.'\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    success: true,\n    action: 'delete',\n    message: `Deleted task \"${result.name}\" successfully.`\n  }\n}];"
        }
      },
      {
        "id": "invalid-action",
        "name": "Invalid Action",
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [900, 660],
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "success",
                "name": "success",
                "value": false,
                "type": "boolean"
              },
              {
                "id": "error",
                "name": "error",
                "value": "={{ 'Invalid action: ' + $('Workflow Input').item.json.action + '. Valid actions: create, list, update, delete' }}",
                "type": "string"
              }
            ]
          },
          "options": {}
        }
      }
    ],
    "connections": {
      "Workflow Input": {
        "main": [[{ "node": "Get User", "type": "main", "index": 0 }]]
      },
      "Get User": {
        "main": [[{ "node": "Route by Action", "type": "main", "index": 0 }]]
      },
      "Route by Action": {
        "main": [
          [{ "node": "Create Task", "type": "main", "index": 0 }],
          [{ "node": "List Tasks", "type": "main", "index": 0 }],
          [{ "node": "Update Task", "type": "main", "index": 0 }],
          [{ "node": "Delete Task", "type": "main", "index": 0 }],
          [{ "node": "Invalid Action", "type": "main", "index": 0 }]
        ]
      },
      "Create Task": {
        "main": [[{ "node": "Insert Task", "type": "main", "index": 0 }]]
      },
      "Insert Task": {
        "main": [
          [{ "node": "Format Create Response", "type": "main", "index": 0 }]
        ]
      },
      "List Tasks": {
        "main": [
          [{ "node": "Format List Response", "type": "main", "index": 0 }]
        ]
      },
      "Update Task": {
        "main": [
          [{ "node": "Format Update Response", "type": "main", "index": 0 }]
        ]
      },
      "Delete Task": {
        "main": [
          [{ "node": "Format Delete Response", "type": "main", "index": 0 }]
        ]
      }
    },
    "authors": "Spencer Marx",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-04T12:12:31.902Z",
        "id": 199,
        "workflowId": "GVUVTmfFfdIpApKq",
        "versionId": "851e0a8b-513d-4600-9e6e-c863afc3ade1",
        "event": "activated",
        "userId": "e498ff06-ba9d-4721-8454-492195be8229"
      }
    ]
  }
}
